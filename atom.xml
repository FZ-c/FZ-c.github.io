<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老陈的程序员之路</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://FZ-c.github.io/"/>
  <updated>2020-07-08T11:09:34.911Z</updated>
  <id>http://FZ-c.github.io/</id>
  
  <author>
    <name>FZChen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode刷题记录7-7</title>
    <link href="http://FZ-c.github.io/2020/07/08/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%957-7/"/>
    <id>http://FZ-c.github.io/2020/07/08/LeetCode刷题记录7-7/</id>
    <published>2020-07-08T00:55:36.319Z</published>
    <updated>2020-07-08T11:09:34.911Z</updated>
    
    <content type="html"><![CDATA[<p>（646）最长数对链、（1227）飞机座位分配概率、（1301）最大得分的路径数目、（面试题08.01）三步问题、（面试题17.14）最小K个数，（面试题）直方图的水量</p><a id="more"></a><h2 id="646-最长数对链"><a href="#646-最长数对链" class="headerlink" title="646.最长数对链"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/" target="_blank" rel="noopener">646.最长数对链</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。</p><p>现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。</p><p>给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p><p>示例 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2], [2,3], [3,4]]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长的数对链是 [1,2] -&gt; [3,4]</span><br></pre></td></tr></table></figure><p>注意：</p><font color="#87CEFA">给出数对的个数在 [1, 1000] 范围内。</font><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>采用贪心算法，每次在可选的选择中选择第二个数字更小的数对进行连接。</p><p>联想看电视问题，选的结束时间越早，留给后面看其他节目的时间就越多。所以贪心策略是选择可选项中结束时间最早的。</p><p>时间复杂度$O(nlogn)$，空间复杂度$O(1)$。</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">sort(pairs.begin(), pairs.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123;</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">-10000000</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (last &lt; pairs[i][<span class="number">0</span>]) &#123;</span><br><span class="line">ans++;</span><br><span class="line">last = pairs[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>dp解法：</p><p>将所有数对按照第一个数升序，相同则按第二个数升序排列，$dp[i]$代表第$i$个数对进行连接后，最长可以达到的数链长度。</p><p>dp数组的所有值的默认值为1，因为数对本身就是一个数链。则按照链接的要求，可以得到下式：</p><script type="math/tex; mode=display">dp[i]=\begin{cases} max(dp[i],dp[k]+1)\ , & nums[k][1]<nums[i][0] \\ dp[i], & else \end{cases}\ (k=0,1,\dots,n-1)</script><p>就是当$nums[i]$可以在$nums[k]$的后方时，就可以将$nums[i]$插入到$nums[k]$所组成的最长的数链的后方，则最长长链长度为$dp[k]+1$。</p><p>所有可以链接的长链的长度的最大值即为当前数对可形成的最长长链。$dp[n]$即为答案。</p><p>时间复杂度为$O(n^2)$，空间复杂度$O(n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">sort(pairs.begin(), pairs.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(pairs.size(), <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pairs.size(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (pairs[j][<span class="number">1</span>] &lt; pairs[i][<span class="number">0</span>]) &#123;</span><br><span class="line">dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于前面有进行排序，显然$dp$数组是单调递增的。所以，我们可以对上面的代码进行优化：使用二分法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">sort(pairs.begin(), pairs.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : pairs) &#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = dp.size();</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (dp[mid][<span class="number">1</span>] &gt;= p[<span class="number">0</span>])right = mid;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= dp.size())dp.emplace_back(p);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dp[left][<span class="number">1</span>] &gt; p[<span class="number">1</span>])dp[left] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1227-飞机座位分配概率"><a href="#1227-飞机座位分配概率" class="headerlink" title="1227.飞机座位分配概率"></a><a href="https://leetcode-cn.com/problems/airplane-seat-assignment-probability/" target="_blank" rel="noopener">1227.飞机座位分配概率</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。</p><p>剩下的乘客将会：</p><pre><code>如果他们自己的座位还空着，就坐到自己的座位上，当他们自己的座位被占用时，随机选择其他座位</code></pre><p>第 n 位乘客坐在自己的座位上的概率是多少？</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入：n = 1</span><br><span class="line">输出：1.00000</span><br><span class="line">解释：第一个人只会坐在自己的位置上。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入: n = 2</span><br><span class="line">输出: 0.50000</span><br><span class="line">解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。</span><br></pre></td></tr></table></figure><p>提示：</p><font color="#87CEFA">1 ≤ n ≤ 10^5</font><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><del>试了几个样例发现规律直接过了</del></p><p>考虑$n=1$的情况，由于飞机上只有一个座位，他必定会坐在自己的位置上，答案为1。</p><p>考虑$n &gt; 1$的情况：</p><p>第$1$个人坐在第$n$个人的座位上的可能性是$F(1)=\frac{1}{n}$。</p><p>第$2$个人坐在第$n$个人的座位上的前提是第$1$个人坐在第$2$个人的座位上（因为只有自己的座位被占用时，才会选择其它座位），概率是$P(2)=F(1)=\frac{1}{n}$。</p><p>对于第$2$个人来说，他有$n-1$个座位可选，所以第$2$个人坐在第$n$个人的座位上的概率是$F(2)=P(2)\times\frac{1}{n-1}=\frac{1}{n-1}-\frac{1}{n}$。</p><p>此时，第$n$个人坐不到自己的座位的可能是$F(1)+F(2)=\frac{1}{n-1}$。</p><p>对于第$3$个人来说，他坐在第$n$个人的前提是第$1$个人坐在第$2$个人的座位上，第$2$个人坐在第$3$个人的座位上，概率是$F(2)=\frac{1}{n-1}-\frac{1}{n}$；或者第$1$个人坐在第$3$个人的座位上，概率是$F(1)=\frac{1}{n}$，即$P(3)=F(1)+F(2)=\frac{1}{n-1}$。</p><p>对于第$3$个人来说，他有$n-2$个座位可选，所以第$3$个人坐在第$n$个人的座位上的概率是$F(3)=P(3)\times\frac{1}{n-2}=\frac{1}{n-2}-\frac{1}{n-1}$。</p><p>此时，第$n$个人坐不到自己的座位的可能是$F(1)+F(2)+F(3)=\frac{1}{n-2}$。</p><p>以此类推，对于第$i$个人来说，他坐在第$n$个人的位置上的前提概率是$P(i)=F(1)+F(2)+\dots+F(i-1)=\frac{1}{n-i-2}$。坐在第$n$个人的座位上的概率是$F(i)=P(i)\times\frac{1}{n-i+1}=\frac{1}{n-i-2}-\frac{1}{n-i+1}$。</p><p>此时，第$n$个人坐不到自己的座位的概率是$F(1)+F(2)+\dots+F(i)=\frac{1}{n-i+1}$。</p><p>那么，对于第$n-1$坐下之后，第$n$个人坐不到自己座位的概率是$F(1)+F(2)+\dots+F(n-1)=\frac{1}{2}$。</p><p>所以，第$n$个人能坐在自己座位的概率是$1-\frac{1}{2}=\frac{1}{2}$。</p><h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">nthPersonGetsNthSeat</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1301-最大得分的路径数目"><a href="#1301-最大得分的路径数目" class="headerlink" title="1301. 最大得分的路径数目"></a><a href="https://leetcode-cn.com/problems/number-of-paths-with-max-score/" target="_blank" rel="noopener">1301. 最大得分的路径数目</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个正方形字符数组 board ，你从数组最右下方的字符 ‘S’ 出发。</p><p>你的目标是到达数组最左上角的字符 ‘E’ ，数组剩余的部分为数字字符 1, 2, …, 9 或者障碍 ‘X’。在每一步移动中，你可以向上、向左或者左上方移动，可以移动的前提是到达的格子没有障碍。</p><p>一条路径的 「得分」 定义为：路径上所有数字的和。</p><p>请你返回一个列表，包含两个整数：第一个整数是 「得分」 的最大值，第二个整数是得到最大得分的方案数，请把结果对 10^9 + 7 取余。</p><p>如果没有任何路径可以到达终点，请返回 [0, 0] 。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [&quot;E23&quot;,&quot;2X2&quot;,&quot;12S&quot;]</span><br><span class="line">输出：[7,1]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [&quot;E12&quot;,&quot;1X1&quot;,&quot;21S&quot;]</span><br><span class="line">输出：[4,2]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [&quot;E11&quot;,&quot;XXX&quot;,&quot;11S&quot;]</span><br><span class="line">输出：[0,0]</span><br></pre></td></tr></table></figure><p>提示：</p><font color="#87CEFA">2 <= board.length="=" board[i].length <="100</font"><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>很明显的dp。</p><p>但是题目输入比较反人类，就是把起点设在了右下角终点设在了左下角。<del>虽然说没关系但是我还是要吐槽一下</del></p><p>设置一个pair类型的dp数组，第一个值存最大分值，第二个值存路径数。</p><p>我们发现，对于中间的某一个点$(x,y)$，它可以从$(x+1,y),(x,y+1),(x+1,y+1)$这三个点移动得来。</p><p>所以可以通过下面的方式递推：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前一个点不是障碍物且没越界时</span></span><br><span class="line"><span class="keyword">if</span>(i+<span class="number">1</span>&lt;board.size()&amp;&amp;board[i+<span class="number">1</span>][j]!=<span class="string">'X'</span>) &#123;</span><br><span class="line">    <span class="comment">//如果从这个方向移动可以得到更大的分数则更新分数和路径数</span></span><br><span class="line">    <span class="keyword">if</span>(dp[i][j].first&lt;dp[i+<span class="number">1</span>][j].first) dp[i][j]=dp[i+<span class="number">1</span>][j];</span><br><span class="line">    <span class="comment">//如果分数与当前最大的相同，则将增加当前的路径数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dp[i][j].first==dp[i+<span class="number">1</span>][j].first) dp[i][j].second+=dp[i+<span class="number">1</span>][j].second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后处理一下特殊情况，如果没有路径可以到终点，则要设置最大分数为0。（因为最大分数可能由于附近的数而非0）</p><h3 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pathsWithMaxScore(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board) &#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[board.size() - <span class="number">1</span>][board.size() - <span class="number">1</span>].second = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = board.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = board.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> ((board[i][j] &lt; <span class="string">'0'</span> || board[i][j]&gt;<span class="string">'9'</span>) &amp;&amp; board[i][j] != <span class="string">'E'</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; board.size() &amp;&amp; board[i + <span class="number">1</span>][j] != <span class="string">'X'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j].first &lt; dp[i + <span class="number">1</span>][j].first) dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dp[i][j].first == dp[i + <span class="number">1</span>][j].first) dp[i][j].second += dp[i + <span class="number">1</span>][j].second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">1</span> &lt; board.size() &amp;&amp; board[i][j + <span class="number">1</span>] != <span class="string">'X'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j].first &lt; dp[i][j + <span class="number">1</span>].first) dp[i][j] = dp[i][j + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dp[i][j].first == dp[i][j + <span class="number">1</span>].first) dp[i][j].second += dp[i][j + <span class="number">1</span>].second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; board.size() &amp;&amp; j + <span class="number">1</span> &lt; board.size() &amp;&amp; board[i + <span class="number">1</span>][j + <span class="number">1</span>] != <span class="string">'X'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j].first &lt; dp[i + <span class="number">1</span>][j + <span class="number">1</span>].first) dp[i][j] = dp[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dp[i][j].first == dp[i + <span class="number">1</span>][j + <span class="number">1</span>].first) dp[i][j].second += dp[i + <span class="number">1</span>][j + <span class="number">1</span>].second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (board[i][j] != <span class="string">'E'</span>) dp[i][j].first += (board[i][j] - <span class="string">'0'</span>);</span><br><span class="line">dp[i][j].first %= <span class="number">1000000007</span>;</span><br><span class="line">dp[i][j].second %= <span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;dp[<span class="number">0</span>][<span class="number">0</span>].second==<span class="number">0</span>?<span class="number">0</span>:dp[<span class="number">0</span>][<span class="number">0</span>].first,dp[<span class="number">0</span>][<span class="number">0</span>].second&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题-08-01-三步问题"><a href="#面试题-08-01-三步问题" class="headerlink" title="面试题 08.01. 三步问题"></a><a href="https://leetcode-cn.com/problems/three-steps-problem-lcci/" target="_blank" rel="noopener">面试题 08.01. 三步问题</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。</p><p>示例1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3 </span><br><span class="line">输出：4</span><br><span class="line">说明: 有四种走法</span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：13</span><br></pre></td></tr></table></figure><p>提示:</p><font color="#87CEFA">n范围在[1, 1000000]之间</font><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>没啥好说的，很直接的斐波那契的变形。</p><h3 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waysToStep</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">1000010</span>] = &#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">ans[i] = ((ans[i - <span class="number">1</span>] + ans[i - <span class="number">2</span>]) % <span class="number">1000000007</span> + ans[i - <span class="number">3</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题-17-14-最小K个数"><a href="#面试题-17-14-最小K个数" class="headerlink" title="面试题 17.14. 最小K个数"></a><a href="https://leetcode-cn.com/problems/smallest-k-lcci/" target="_blank" rel="noopener">面试题 17.14. 最小K个数</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： arr = [1,3,5,7,2,4,6,8], k = 4</span><br><span class="line">输出： [1,2,3,4]</span><br></pre></td></tr></table></figure><p>提示：</p><font color="#87CEFA">0 <= len(arr) <="100000</font"><font color="#87CEFA">0 <= k <="min(100000," len(arr))< font><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>快排，然后直接出结果。时间复杂度$O(nlogn)$。</p><h3 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; smallestK(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">sort(arr.begin(), arr.end());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ret;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) ret.push_back(arr[i]);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h3><p>（待补坑）</p><p>使用堆排序，时间复杂度$O(nlogk)$。</p><p>使用BFPRT算法，随机快速选择算法，时间复杂度$O(n)$。</p><h2 id="面试题-17-21-直方图的水量"><a href="#面试题-17-21-直方图的水量" class="headerlink" title="面试题 17.21. 直方图的水量"></a><a href="https://leetcode-cn.com/problems/volume-of-histogram-lcci/" target="_blank" rel="noopener">面试题 17.21. 直方图的水量</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。</p><p><img src="/2020/07/08/LeetCode刷题记录7-7/E:/Blog\source\_posts\LeetCode刷题记录7-7\111.png" alt></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。 感谢 Marcos 贡献此图。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>预处理一通每一个点的左边的最大值和右边的最大值。然后对每个点判断会不会积水累加即可。</p><p>（双指针会更快，省去了预处理的过程）</p><h3 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (height.empty())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, mmax = height[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ml(height), mr(height);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ml.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ml[i] &gt; mmax) mmax = ml[i];</span><br><span class="line">ml[i] = mmax;</span><br><span class="line">&#125;</span><br><span class="line">mmax = height[height.size() - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mr.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (mr[i] &gt; mmax) mmax = mr[i];</span><br><span class="line">mr[i] = mmax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ml[i] &gt; height[i] &amp;&amp; mr[i] &gt; height[i])</span><br><span class="line">ans += min(ml[i], mr[i]) - height[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></=></font></=></font></=></font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（646）最长数对链、（1227）飞机座位分配概率、（1301）最大得分的路径数目、（面试题08.01）三步问题、（面试题17.14）最小K个数，（面试题）直方图的水量&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://FZ-c.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://FZ-c.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2019CCPC江西省赛</title>
    <link href="http://FZ-c.github.io/2019/07/21/2019CCPC%E6%B1%9F%E8%A5%BF%E7%9C%81%E8%B5%9B/"/>
    <id>http://FZ-c.github.io/2019/07/21/2019CCPC江西省赛/</id>
    <published>2019-07-21T07:01:42.000Z</published>
    <updated>2019-07-21T12:25:51.117Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=868" target="_blank" rel="noopener">http://acm.hdu.edu.cn/contests/contest_show.php?cid=868</a></p><a id="more"></a><p>很让人开心的一场重现赛，听说比较简单所以打了，还真的挺简单（肥佬笑）。退役辣鸡感觉自己还没老.jpg</p><h1 id="A-Cotree"><a href="#A-Cotree" class="headerlink" title="A. Cotree"></a>A. Cotree</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定两棵树，要求增加一条边，求$\sum_{i=1}^n\sum_{j=i+1}^n dis(i,j)$的最小值。</p><p>$dis(i,j)$的值为结点$i$到$j$所需要经过的边的数量。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="B-Math"><a href="#B-Math" class="headerlink" title="B. Math"></a>B. Math</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>待补</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="C-Trap"><a href="#C-Trap" class="headerlink" title="C. Trap"></a>C. Trap</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定$N$条线段的长度，问能组成四条边的长度的最大公因子是1的等腰梯形的个数。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="D-Wave"><a href="#D-Wave" class="headerlink" title="D. Wave"></a>D. Wave</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>定义波动序列是奇数位置的数相同、偶数位置的数相同但是奇数位置和偶数位置的数不相同的序列。</p><p>给定序列求最长的波动子序列的长度。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于给出了序列的数的范围(在$1-c(c\leq 100)$之间），所以考虑枚举组成波动序列的两个数求出答案取最值即可。复杂度$O(nc^2)$。</p><p>不过貌似会超时，考虑记录位置后双指针寻找答案即可。<del>自己的写丑了</del>（感谢鶸叶大佬的建议）</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">100100</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> now_pos = min(pos[a][<span class="number">0</span>], pos[b][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> pos_a = <span class="number">0</span>, pos_b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (now_pos == pos[a][<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (pos[b][pos_b] &lt; pos[a][pos_a])</span><br><span class="line">pos_b++;</span><br><span class="line"><span class="keyword">if</span> (pos_b &lt; pos[b].size()) ans++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pos_a &lt; pos[a].size() &amp;&amp; pos_b &lt; pos[b].size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (pos_a &lt; pos[a].size() &amp;&amp; pos[a][pos_a] &lt; pos[b][pos_b])</span><br><span class="line">pos_a++;</span><br><span class="line"><span class="keyword">if</span> (pos_a &gt;= pos[a].size()) <span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">else</span> ans++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pos_b &lt; pos[b].size() &amp;&amp; pos[a][pos_a] &gt; pos[b][pos_b])</span><br><span class="line">pos_b++;</span><br><span class="line"><span class="keyword">if</span> (pos_b &gt;= pos[b].size()) <span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">else</span> ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, c;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">pos[num[i]].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pos[i].size() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pos[j].size() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">ans = max(slove(i, j), ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没加就PE</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-Packing"><a href="#E-Packing" class="headerlink" title="E. Packing"></a>E. Packing</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>待补</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="F-String"><a href="#F-String" class="headerlink" title="F. String"></a>F. String</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串$s$，将在其中均匀随机地选择四个字母（选择的字母可以重复），求这四个字母是”avin”的概率。</p><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>显然，分母就是$(len(s))^4$。</p><p>由于四个字母顺序可以改变，那么符合题目的选择情况就是$a的选择情况数\times v的选择情况数\times i的选择情况数 \times n的选择情况数$。</p><p>那么，记录四个字母出现的次数相乘即为分母。约分一下即为答案。</p><p>复杂度$O(n)$。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'a'</span>)num[<span class="number">0</span>]++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'v'</span>)num[<span class="number">1</span>]++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'i'</span>)num[<span class="number">2</span>]++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'n'</span>)num[<span class="number">3</span>]++;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;ll, ll&gt;ans;</span><br><span class="line">ans.first = num[<span class="number">0</span>];</span><br><span class="line">ans.second = (ll)n * n * n * n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">ans.first *= num[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans.first == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"0/1\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ll x = gcd(ans.first, ans.second);</span><br><span class="line">ans.first /= x;</span><br><span class="line">ans.second /= x;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans.first &lt;&lt; <span class="string">'/'</span> &lt;&lt; ans.second &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="G-Traffic"><a href="#G-Traffic" class="headerlink" title="G. Traffic"></a>G. Traffic</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个十字路口，东西走向的有$n$辆车，分别会在$a_i$时间通过十字路口，南北走向的有$m$辆车，分别会在$b_i$时间通过十字路口。但是当东西方向的车与南北方向的车在同一时间通过十字路口就会发生交通事故。</p><p>为了避免交通事故的发生，现将南北方向的车的通过时间延后$x$分钟，求最小的$x$。</p><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于$a_i,b_i$的数据范围都不大于$10^3$。那么显然答案的最大值就是$10^3$。枚举答案判断合法即可。</p><p>复杂度$O(10^3\times m)$。</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nnum[<span class="number">1100</span>], mnum[<span class="number">1100</span>];</span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">1100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, nnum + i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, mnum + i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pos[nnum[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> isans = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (pos[mnum[j] + i] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    isans = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isans)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(nnum, <span class="number">0</span>, <span class="keyword">sizeof</span>(nnum));</span><br><span class="line">        <span class="built_in">memset</span>(mnum, <span class="number">0</span>, <span class="keyword">sizeof</span>(mnum));</span><br><span class="line">        <span class="built_in">memset</span>(pos, <span class="number">0</span>, <span class="keyword">sizeof</span>(pos));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="H-Rng"><a href="#H-Rng" class="headerlink" title="H. Rng"></a>H. Rng</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>随机产生两个$1-n$的区间$[l,r],[l’,r’]$。求两区间相交的概率。</p><h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>考虑计算不相交的概率。</p><p>假设区间$[l,r],[l’,r’]$不相交，那么必有$r&lt;l’$（假设第一个区间在前，第二个在后）。</p><p>若$l’$的值为$x$，则不相交的$r$的取值情况共有$x-1$种。</p><p>又$l’$的取值情况共有$n$种，则不相交的情况就是$\sum_{i=1}^{n-1}i$种。</p><p>除以总情况数减去就是区间相交的概率。</p><p>即：</p><script type="math/tex; mode=display">P=1-\frac{\sum_{i=1}^{n-1}i}{n^2}=1-\frac{(n-1)\times n}{2n^2}=\frac{n+1}{2n}</script><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll i, ll mmod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (mmod - mmod / i) * inv(mmod % i, mmod) % mmod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    ll MMod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ((n + <span class="number">1</span>) * inv(<span class="number">2</span> * n, MMod)) % MMod &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="I-Budget"><a href="#I-Budget" class="headerlink" title="I. Budget"></a>I. Budget</h1><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出$n$个三位小数，现在要将他们四舍五入为两位小数。求产生的总误差。</p><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>本来用double模拟了一发发现WA了，debug发现卡精度整个人都不好了。</p><p>随即用字符串来做，做到一半突然发现可以不做四舍五入的操作直接计算。</p><blockquote><p>若最后一位$\geq 5$，则误差为$(10-最后一位)/1000$。</p><p>若最后一位$&lt;5$，则误差为$-最后一位/1000$。</p></blockquote><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll x;</span><br><span class="line">            <span class="keyword">char</span> input[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld.%s%*c"</span>, &amp;x, input);</span><br><span class="line">            <span class="keyword">if</span> (input[<span class="number">2</span>] - <span class="string">'0'</span> &gt;= <span class="number">5</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += <span class="number">10</span> - input[<span class="number">2</span>] + <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans -= input[<span class="number">2</span>] - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, ans / <span class="number">1000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="J-Worker"><a href="#J-Worker" class="headerlink" title="J. Worker"></a>J. Worker</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定数组$A$和一个数$m$。问是否存在$x_1+x_2+\dots+x_n=m$，能使$a_1\times x_1=a_2\times x_2=\dots=a_n \times x_n$。</p><h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>显然，最小的相等值就是$lcm(a_1,a_2,\dots,a_n)$。</p><p>对于每个数，算出需要乘的数$p_i$，累加起来得到$P$。</p><p>则有判断$m$是否是$P$的倍数即可。</p><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">1100</span>];</span><br><span class="line">ll fen[<span class="number">1100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, num + i);</span><br><span class="line">        ll x = num[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            x = lcm(x, num[i]);</span><br><span class="line">        ll sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fen[i] = x / num[i];</span><br><span class="line">            sum += fen[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m % sum == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            ll xxx = m / sum;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld "</span>, xxx * fen[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, xxx * fen[n - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="K-Class"><a href="#K-Class" class="headerlink" title="K. Class"></a>K. Class</h1><h2 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定$x=a+b、y=a-b$，求$a\times b$的值。</p><h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><p>$a=\frac{x+y}{2},b=x-a$。</p><h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, a, b;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        a = (x + y) / <span class="number">2</span>;</span><br><span class="line">        b = x - a;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a * b &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://acm.hdu.edu.cn/contests/contest_show.php?cid=868&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://acm.hdu.edu.cn/contests/contest_show.php?cid=868&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="HDU" scheme="http://FZ-c.github.io/categories/HDU/"/>
    
    
      <category term="ACM" scheme="http://FZ-c.github.io/tags/ACM/"/>
    
      <category term="CCPC" scheme="http://FZ-c.github.io/tags/CCPC/"/>
    
  </entry>
  
  <entry>
    <title>2019牛客多校第二场</title>
    <link href="http://FZ-c.github.io/2019/07/20/2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BA/"/>
    <id>http://FZ-c.github.io/2019/07/20/2019牛客多校第二场/</id>
    <published>2019-07-20T10:58:42.000Z</published>
    <updated>2019-07-20T14:52:12.573Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/882#question" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/882#question</a></p><a id="more"></a><h1 id="A-Eddy-Walker"><a href="#A-Eddy-Walker" class="headerlink" title="A. Eddy Walker"></a>A. Eddy Walker</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>待补</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="B-Eddy-Walker-2"><a href="#B-Eddy-Walker-2" class="headerlink" title="B. Eddy Walker 2"></a>B. Eddy Walker 2</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>有一人位于点0处，每次独立均匀且随机的移动$1-K$个单位距离，移动无限次。若$N \neq -1$，则求此人移动到位置$N$的概率。若$N=-1$，则求当$N \rightarrow \infty$时，移动到$N$的概率。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="C-Go-on-Strike"><a href="#C-Go-on-Strike" class="headerlink" title="C. Go on Strike!"></a>C. Go on Strike!</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>有$N$座城市，每天会增加一条$u$城市到$v$城市的航班，花费为$c$或者有一条已经存在的航班因为某些原因<del>（欠工资）</del>停航。</p><p>对于每天的航线情况，求这$N$座城市两两之间使用最少花费的航班需要最多的航班数。如果存在城市无法到达，输出”-1”。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="D-Kth-Minimum-Clique"><a href="#D-Kth-Minimum-Clique" class="headerlink" title="D. Kth Minimum Clique"></a>D. Kth Minimum Clique</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个包含$N$个点的点带权无向图，求点权和第$K$小的完全子图。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="E-MAZE"><a href="#E-MAZE" class="headerlink" title="E. MAZE"></a>E. MAZE</h1><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个$N \times M$的地图，有$Q$个操作：</p><blockquote><ol><li>将第$x$行第$y$列的可行转态改变。（即如果当前位置可以通过，则变成不可通过，反之亦然）</li><li>求从第$1$行第$x$列开始到第$N$行第$y$列可走的路径数。</li></ol></blockquote><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="F-Partition-problem"><a href="#F-Partition-problem" class="headerlink" title="F. Partition problem"></a>F. Partition problem</h1><h2 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h2><p>现有$2N$个人需要分成两个组，每组$N$人。给定一个$2\times N$的矩阵$v$，第$i$行第$j$列表示第$i$个人与第$j$个人的竞争力差。</p><p>求两个队伍的竞争力差的最大值。（两队伍竞争力差为每对不在同一队伍的人的竞争力差的和）</p><p>更格式化地说，团队竞争力差为$\sum_{i=1}^{2N}\sum_{j=i+1}^{2N}(v_{ij} 当第i个人与第j个人不在同一团队)$。</p><p>求$E$的期望值，输出$36 \times E$。</p><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="G-Polygons"><a href="#G-Polygons" class="headerlink" title="G. Polygons"></a>G. Polygons</h1><h2 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定$N$条直线，求能围成的多边形数、最大面积、最小面积和第$K$大的多边形面积。</p><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="H-Second-Large-Rectangle"><a href="#H-Second-Large-Rectangle" class="headerlink" title="H. Second Large Rectangle"></a>H. Second Large Rectangle</h1><h2 id="题目大意-7"><a href="#题目大意-7" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定$N \times M$的矩阵，求第二大的所有值都是1的矩形大小。</p><h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="I-Inside-A-Rectangle"><a href="#I-Inside-A-Rectangle" class="headerlink" title="I. Inside A Rectangle"></a>I. Inside A Rectangle</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个$N \times M$的矩阵，选择两个矩形，求仅在其中一个矩形中的数的和的最大值。</p><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="J-Subarray"><a href="#J-Subarray" class="headerlink" title="J. Subarray"></a>J. Subarray</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有长度为$10^9$的数组$A$，所有值均为$1$或者$-1$。</p><p>现给出值为$1$的区域段，即给定$l,r$，有$A_x=1(l \leq x\leq r)$。</p><p>求有多少对$(l,r)$满足$\sum_{i=l}^rA_i&gt;0$。</p><h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><p>待补</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/882#question&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/882#question&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="牛客" scheme="http://FZ-c.github.io/categories/%E7%89%9B%E5%AE%A2/"/>
    
    
      <category term="ACM" scheme="http://FZ-c.github.io/tags/ACM/"/>
    
      <category term="多校" scheme="http://FZ-c.github.io/tags/%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>2019牛客多校第一场</title>
    <link href="http://FZ-c.github.io/2019/07/18/2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA/"/>
    <id>http://FZ-c.github.io/2019/07/18/2019牛客多校第一场/</id>
    <published>2019-07-18T14:58:42.000Z</published>
    <updated>2019-07-18T17:10:17.645Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://ac.nowcoder.com/acm/contest/881#question" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/881#question</a></p><a id="more"></a><h1 id="A-Equivalent-Prefixes"><a href="#A-Equivalent-Prefixes" class="headerlink" title="A. Equivalent Prefixes"></a>A. Equivalent Prefixes</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定两个$1-n$的排列$u$和$v$，求最长的前缀$p$，使得对于任意的$1\leq l \leq r\leq q$，都有$RMQ(u,l,r)=RMQ(v,l,r)$。</p><p>$RMQ(w,l,r)$的值为$w_l,w_{l+1},\dots,w_{r}$的最小值。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="B-Integration"><a href="#B-Integration" class="headerlink" title="B. Integration"></a>B. Integration</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>已知$\int_0^{\infty}\frac{1}{1+x^2}dx=\frac{\pi}{2}$。给定数组$a$，求$\frac{1}{\pi}\int_0^{\infty}\frac{1}{\prod{\left( a_i^2+x^2 \right) }}dx$的值。假设结果为$\frac{p}{q}$，输出$p \cdot q^{-1} $。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="C-Euclidean-Distance"><a href="#C-Euclidean-Distance" class="headerlink" title="C. Euclidean Distance"></a>C. Euclidean Distance</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个$n$维点的坐标$A\left( \frac{a_1}{m},\frac{a_2}{m},\dots,\frac{a_n}{m}\right)$，其中$a_i$和$m$均为整数。现需要求$P\left(p_1,p_2,\dots,p_n\right)$满足：</p><ol><li>$p_1,p_2,\dots,p_n$均为非负实数</li><li>$p_1+p_2+\dots+p_n=1$</li><li>与$A$的距离$D=\sum_{i=1}^n \left( \frac{a_i}{m}-p_i\right)^2$最小。</li></ol><p>输出$D^2$。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="D-Parity-of-Tuples"><a href="#D-Parity-of-Tuples" class="headerlink" title="D. Parity of Tuples"></a>D. Parity of Tuples</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定$n$个$m$元组$v_i=\left(a_{i,1},a_{i,2},\dots,a_{i,m}\right)$，定义函数$count(x)$的值为能使得对于所有的$j$，均有$a_{i,j} \wedge x$的结果的二进制拥有奇数个1的元组$v_i$的个数。</p><p>求$\bigoplus_{x=0}^{2^k-1}\left(count(x) \cdot 3^x mod \left(10^9+7\right)\right)$的值，$\bigoplus$为按位异或。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="E-ABBA"><a href="#E-ABBA" class="headerlink" title="E. ABBA"></a>E. ABBA</h1><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p>求可以分解成$n$个”AB”子序列和$m$个“BA”子序列的长度为$2(n+m)$的字符串的种类数$(mod 10^9+7)$。</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="F-Random-Point-in-Triangle"><a href="#F-Random-Point-in-Triangle" class="headerlink" title="F. Random Point in Triangle"></a>F. Random Point in Triangle</h1><h2 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定三角形$ABC$的三个点坐标$A,B,C$，现在三角形中均匀地取一点$P$，定义$E:=max \left( S_{\Delta PAB},S_{\Delta PBC},S_{\Delta PCA} \right)$，其中$S_{\Delta XYZ}$表示三角形$XYZ$的面积。</p><p>求$E$的期望值，输出$36 \times E$。</p><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="G-Substrings-2"><a href="#G-Substrings-2" class="headerlink" title="G. Substrings 2"></a>G. Substrings 2</h1><h2 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h2><p>定义两字符串$u(u_1,u_2,\dots,u_k),v(v_1,v_2,\dots,v_l)$同构当且仅当$k=l$且存在一个映射$\phi$对于$i\in \{1,2,\dots,k\}$有$u_i=\phi(v_i)$成立。</p><p>映射：当且仅当$x \neq y$时有$f(x) \neq f(y)$，称$f$为一个映射。</p><p>给定一个字符串$s$，求最多能选出的子串的数量满足两两均不同构。</p><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="H-XOR"><a href="#H-XOR" class="headerlink" title="H. XOR"></a>H. XOR</h1><h2 id="题目大意-7"><a href="#题目大意-7" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定集合$A$，求所有$A$的子集$S$满足$S$的所有元素异或和为0的集合$S$的大小的和$(mod  10^9+7)$。</p><p>即求：</p><script type="math/tex; mode=display">\left(\sum_{S\subseteq A,\oplus_{x \in S}x=0}\midS\mid \right)mod\ (10^9+7)</script><p>其中，$\oplus$为按位异或。</p><h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="I-Points-Division"><a href="#I-Points-Division" class="headerlink" title="I. Points Division"></a>I. Points Division</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个拥有$n$个点的集合$P\{(x_1,y_1),(x_2,y_2),\dots,(x_n,y_n)\}$，每个点拥有两个权值$a_i,b_i$。</p><p>现将集合$P$分割成两部分$A,B$。</p><p>定义一个分割$(A,B)$有效当且仅当不存在$i \in A$且$j \in B$，有$x_i \geq x_j$且$y_i \leq y_j$。</p><p>求所有有效分割$(A,B)$中$\left( \sum_{i \in A}a_i\right)+\left( \sum_{j \in B}b_i\right)$的最大值。</p><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><p>待补</p><h1 id="J-Fraction-Comparision"><a href="#J-Fraction-Comparision" class="headerlink" title="J. Fraction Comparision"></a>J. Fraction Comparision</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个分数$\frac{x}{a}$和$\frac{y}{b}$，比较他们的大小情况。</p><h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>待补</p><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><p>待补</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/881#question&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/881#question&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="牛客" scheme="http://FZ-c.github.io/categories/%E7%89%9B%E5%AE%A2/"/>
    
    
      <category term="ACM" scheme="http://FZ-c.github.io/tags/ACM/"/>
    
      <category term="多校" scheme="http://FZ-c.github.io/tags/%E5%A4%9A%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>欧几里得算法及其扩展 最小公倍数</title>
    <link href="http://FZ-c.github.io/2019/05/24/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
    <id>http://FZ-c.github.io/2019/05/24/欧几里得算法及其扩展-最小公倍数/</id>
    <published>2019-05-24T03:39:20.613Z</published>
    <updated>2020-07-08T07:46:04.097Z</updated>
    
    <content type="html"><![CDATA[<p>$ $</p><a id="more"></a><font color="red">注意：本文转载需经过作者同意，违者必究。</font><h1 id="辗转相减法"><a href="#辗转相减法" class="headerlink" title="辗转相减法"></a>辗转相减法</h1><p>首先，先了解一下辗转相减法。</p><blockquote><p>起初两个正整数$a,b$，若$b&gt;a$，则将两数交换。即保证$a\geq b$。</p><p>每次得到$c=a-b , a=b , b=c$。</p><p>若$b&gt;a$，则将两数交换。</p><p>若$b=0$，则最大公因数为$a$。</p></blockquote><p>例如$a=7 , b=2$，我们可以得到下面的序列：</p><script type="math/tex; mode=display">(7,2)\to(5,2)\to(3,2)\to(2,1)\to(1,1)\to(1,0)</script><p>此时，我们可以得到7和2的最大公因子是1。</p><h1 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h1><p>我们观察上面的序列：</p><script type="math/tex; mode=display">(7,2)\to\color{blue}{(5,2)\to(3,2)\to(2,1)}\to(1,1)\to(1,0)</script><p>上面蓝色部分其实是可以省略的。</p><p>我们可以发现，蓝色部分中$b$总是不变的，直到$a&lt;b$。</p><p>而每次都是进行减$b$的操作，那么我们可以得到最后$a$会变成$a\%b$。</p><p>若我们记$gcd(a,b)$的值为$a,b$的最大公因子。那么我们可以得到下面的式子：</p><script type="math/tex; mode=display">gcd(a,b)=\begin{cases} gcd(b,a \% b), & b \neq 0 \\ a, & b=0\end{cases}</script><p>这种计算最大公因子的方法我们称为辗转相除法，也叫欧几里得算法。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归版</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        r=a%b;</span><br><span class="line">        a=b;</span><br><span class="line">        b=r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一个非递归版</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        a%=b;</span><br><span class="line">        swap(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优美的非递归版</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b^=a^=b^=a%=b);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归版</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法正确性证明"><a href="#算法正确性证明" class="headerlink" title="算法正确性证明"></a>算法正确性证明</h2><p>首先，算法执行过程中$a$和$b$都在严格减少，又由于$a$和$b$总是非负，因此算法必定有穷。</p><p>为了证明正确性，我们必须证明$gcd⁡(a,b)=gcd⁡(b,a\%b)$对于所有的$a&gt;0,b&gt;0$均成立。</p><blockquote><p>我们假设$d=gcd⁡(a,b)$。那么我们可以知道：$d|a$且$d|b$。</p><p>那么我们可以得到：</p><script type="math/tex; mode=display">a\%b=a-b×\lfloor\frac{a}{b}\rfloor</script><p>由于$d|a$且$d|b$，那么我们可以得到： $d\mid\left(a-b\times\lfloor\frac{a}{b}\rfloor\right)$。</p><p>即：$d\mid a\%b$</p><p>那么我们目前得到以下结论：</p><script type="math/tex; mode=display">\begin{cases} d\mid b \\ d\mid a\%b\end{cases}</script><p>即：</p><script type="math/tex; mode=display">d=gcd⁡(b,a\%b)</script></blockquote><p>即$gcd⁡(a,b)=gcd⁡(b,a \% b)$得证。</p><h2 id="算法最差情况分析"><a href="#算法最差情况分析" class="headerlink" title="算法最差情况分析"></a>算法最差情况分析</h2><p>对于每次操作，$(a,b)$被$(b,a\%b)$替代。那么最差情况为$a$与$b$的差值最小的情况。</p><p>这种情况发生时我们明显可得：$\frac{b}{a}=1$。</p><p>那么，$gcd⁡(a,b)=gcd⁡(b,a\%b)=gcd⁡(b,a-b)$。</p><p>我们可以发现，若$a,b$为连续斐波那契数，那么该算法在运行时始终满足以上情况。因为：</p><script type="math/tex; mode=display">gcd(F_{x+1},F_x)=gcd(F_x,F_{x-1})=\dots=gcd(F_2,F_1)=gcd(F_1,F_0)=1</script><p>此时该算法的运行次数为$x+1$次。</p><h2 id="算法复杂度证明"><a href="#算法复杂度证明" class="headerlink" title="算法复杂度证明"></a>算法复杂度证明</h2><p>以下谈论的是最差情况下的复杂度。</p><p>由于最差情况与斐波那契数列的增长速率成反比例关系。</p><h3 id="斐波那契数列增长性证明"><a href="#斐波那契数列增长性证明" class="headerlink" title="斐波那契数列增长性证明"></a>斐波那契数列增长性证明</h3><p>首先，由斐波那契数列定义可以得到：</p><script type="math/tex; mode=display">F_n=F_{n-1}+F_{n-2}</script><p>我们将等式左右两边同时除以$F_{n-1}$，得：</p><script type="math/tex; mode=display">\begin{equation} \frac{F_n}{F_{n-1}}=1+\frac{F_{n-2}}{F_{n-1}} \label{eq:formula_1}\end{equation}\tag{1}</script><p>我们记$R_n=\frac{F_n}{F_{n-1}}$，那么对于$\eqref{eq:formula_1}$式，我们有：</p><script type="math/tex; mode=display">\begin{equation} R_n=1+\frac{1}{R_{n-1}} \label{eq:formula_2}\end{equation}\tag{2}</script><p>我们<font color="red">假设</font>：</p><script type="math/tex; mode=display">\begin{equation} \lim_{n\to \infty}R_n=\phi\label{eq:formula_3}\end{equation}\tag{3}</script><p>那么我们有：</p><script type="math/tex; mode=display">\begin{equation} \phi=1+\frac{1}{\phi}\label{eq:formula_4}\end{equation}\tag{4}</script><p>等式左右两边乘以$\phi$，解方程可得：</p><script type="math/tex; mode=display">\begin{equation} \phi_1=\frac{\sqrt{5}+1}{2}\  \ \ \phi_2=\frac{\sqrt{5}-1}{2} \label{eq:formula_5}\end{equation}\tag{5}</script><p>即我们可以得到：$F_n\approx\phi_1F_{n-1}$。（$\phi_2$舍弃，$\phi_1\approx1.618\dots$）</p><p>更进一步地，我们可以得到：</p><script type="math/tex; mode=display">F_n\approx\phi_1^k</script><p>现在证明上面$\eqref{eq:formula_3}$式的假设：</p><p>我们可以把假设等价为：当$n\to \infty$时，$E_n:=R_n-\phi$趋向于0。</p><p>由$\eqref{eq:formula_3}$式和$\eqref{eq:formula_4}$式可得：</p><script type="math/tex; mode=display">E_n=R_n-\phi=\left(1+\frac{1}{R_n-1}\right)-\left(1+\frac{1}{\phi}\right)=\frac{1}{R_{n-1}}-\frac{1}{\phi}=\frac{\phi-R_{n-1}}{\phi R_{n-1}}=-\frac{E_{n-1}}{\phi R_{n-1}}</script><p>我们计算绝对差值：</p><script type="math/tex; mode=display">\mid E_n\mid=\frac{1}{\phi R_{n-1}}\times\mid E_{n-1}\mid</script><p>由于$\phi=\frac{\sqrt{5}-1}{2}&lt;1$，我们可以得到当$n\to\infty$时，$E_n\to 0$。即：</p><script type="math/tex; mode=display">\lim_{n\to \infty}R_n=\phi</script><p>证毕。</p><p>那么由于斐波那契的增长速率类似指数增长：$\phi^k$。</p><p>那么对于上面的算法的输入，计算次数约为$\log_{\phi}{x}$，我们近似为$\log x$次。</p><p>即我们称欧几里得算法的复杂度为$O(\log n)$。</p><h1 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h1><p>待补</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$ $&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://FZ-c.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数论" scheme="http://FZ-c.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="算法" scheme="http://FZ-c.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>积性函数</title>
    <link href="http://FZ-c.github.io/2019/05/23/%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0/"/>
    <id>http://FZ-c.github.io/2019/05/23/积性函数/</id>
    <published>2019-05-23T01:30:28.927Z</published>
    <updated>2019-05-24T05:18:30.191Z</updated>
    
    <content type="html"><![CDATA[<p>先挖一系列的坑，慢慢填~</p><a id="more"></a><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>积性函数：</p><p>对于定义在正整数集上的函数$f(n)$（即算术函数），若当$gcd(a,b)=1$时，有$f(a)f(b)=f(ab)$，则称$f(n)$为积性函数。</p><p>完全积性函数：</p><p>对于积性函数$f(n)$，若当$gcd(a,b)\neq 1$时，$f(a)f(b)=f(ab)$仍然成立，则称$f(x)$是完全积性的。</p><h1 id="常见积性函数"><a href="#常见积性函数" class="headerlink" title="常见积性函数"></a>常见积性函数</h1><h2 id="欧拉函数-phi-n"><a href="#欧拉函数-phi-n" class="headerlink" title="欧拉函数 $\phi(n)$"></a>欧拉函数 $\phi(n)$</h2><p>定义：对于正整数$n$，欧拉函数$\phi(n)$的值等于不大于$n$的数中与$n$互质的数的数量。</p><script type="math/tex; mode=display">\phi(n)=\sum_{1\leq k\leq n}[gcd(n,k)==1]</script><p>博客：待补</p><h2 id="莫比乌斯函数-mu-n"><a href="#莫比乌斯函数-mu-n" class="headerlink" title="莫比乌斯函数 $\mu(n)$"></a>莫比乌斯函数 $\mu(n)$</h2><p>定义：与莫比乌斯反演有关。</p><script type="math/tex; mode=display">\mu(n)=\begin{cases} 1, & \text {n=1} \\ (-1)^k, & \text{n=}p_1p_2\dots p_k\\0,& \text{otherwise} \end{cases}</script><p>博客：待补</p><h2 id="欧几里得求最大公因子-gcd-n-k"><a href="#欧几里得求最大公因子-gcd-n-k" class="headerlink" title="欧几里得求最大公因子 $gcd(n,k)$"></a>欧几里得求最大公因子 $gcd(n,k)$</h2><p>【这里的$k$是固定的】</p><script type="math/tex; mode=display">gcd(n,k)=\begin{cases} gcd(k,n \% k), & k \neq 0 \\ n, & k=0\end{cases}</script><p>博客：待补</p><h2 id="正因子数目-d-n"><a href="#正因子数目-d-n" class="headerlink" title="正因子数目 $d(n)$"></a>正因子数目 $d(n)$</h2><p>定义：对于正整数$n$，$d(n)$的值等于$n$的因子个数。</p><script type="math/tex; mode=display">d(n)=\sum_{1\leq k \leq n}[k|n]</script><p>博客：不存在的</p><h2 id="正因子和-sigma-n"><a href="#正因子和-sigma-n" class="headerlink" title="正因子和 $\sigma(n)$"></a>正因子和 $\sigma(n)$</h2><p>定义：对于正整数$n$，$\sigma(n)$的值等于$n$的所有因子的和。</p><script type="math/tex; mode=display">\sigma(n)=\sum_{k|n}k</script><p>博客：不存在的</p><h2 id="常数函数-1-n"><a href="#常数函数-1-n" class="headerlink" title="常数函数 $1(n)$"></a>常数函数 $1(n)$</h2><p>定义：$1(n)=1$。</p><p>博客：<del>这TMD还要博客？</del></p><h2 id="单位函数-id-n"><a href="#单位函数-id-n" class="headerlink" title="单位函数 $id(n)$"></a>单位函数 $id(n)$</h2><p>定义：$id(n)=n$。</p><p>博客：<del>谁留言要博客我就【数据删除】</del></p><h2 id="狄利克雷卷积的乘法单位-epsilon-n"><a href="#狄利克雷卷积的乘法单位-epsilon-n" class="headerlink" title="狄利克雷卷积的乘法单位 $\epsilon(n)$"></a>狄利克雷卷积的乘法单位 $\epsilon(n)$</h2><p>定义：如标题。</p><script type="math/tex; mode=display">\epsilon(n)=\begin{cases} 0, & n=1 \\ 1, & n>1\end{cases}</script><h2 id="刘维尔函数-lambda-n"><a href="#刘维尔函数-lambda-n" class="headerlink" title="刘维尔函数 $\lambda(n)$"></a>刘维尔函数 $\lambda(n)$</h2><p>定义：<del>我也不知道它是干嘛的。</del></p><script type="math/tex; mode=display">若n=p_1^{k_1}p_2^{k_2}\dots p_x^{k_x}\ ,\ 则\lambda(n)=(-1)^{\sum_{i=1}^{x}k_i}</script><p>博客：待补</p><h1 id="积性函数的性质"><a href="#积性函数的性质" class="headerlink" title="积性函数的性质"></a>积性函数的性质</h1><ol><li>若$n=p_1^{a_1}p_2^{a_2}\dots p_n^{a_n}$且$f(n)$是积性函数，则有$f(n)=f(p_1^{a_1})f(p_2^{a_2})\dots f(p_n^{a_n})$。</li><li>若$f(n)$为积性函数且有$f(p^n)=f^n(p)$，则$f(n)$为完全积性函数。</li><li>非恒等于0的积性函数$f(n)$必有$f(1)=1$。</li><li>积性函数的约数和、前缀和、相互卷积也是积性函数。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先挖一系列的坑，慢慢填~&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://FZ-c.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数论" scheme="http://FZ-c.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="算法" scheme="http://FZ-c.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>莫比乌斯反演</title>
    <link href="http://FZ-c.github.io/2019/05/09/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://FZ-c.github.io/2019/05/09/莫比乌斯反演/</id>
    <published>2019-05-09T05:10:22.398Z</published>
    <updated>2019-05-23T01:31:27.042Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>待更。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;待更。&lt;/p&gt;

      
    
    </summary>
    
      <category term="算法" scheme="http://FZ-c.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数论" scheme="http://FZ-c.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="算法" scheme="http://FZ-c.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2019南昌网络赛</title>
    <link href="http://FZ-c.github.io/2019/04/24/2019%E5%8D%97%E6%98%8C%E7%BD%91%E7%BB%9C%E8%B5%9B/"/>
    <id>http://FZ-c.github.io/2019/04/24/2019南昌网络赛/</id>
    <published>2019-04-24T10:42:42.000Z</published>
    <updated>2019-05-05T15:11:58.043Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://www.jisuanke.com/contest/2290?view=challenges" target="_blank" rel="noopener">https://www.jisuanke.com/contest/2290?view=challenges</a></p><a id="more"></a><p>这次打得很差。<del>（虽然身体状况不大好）</del></p><p>只把最简单的三题做了，一个多小时结束战斗.jpg。</p><p>讨论了半天D，总结了一套贪心，写着写着听到有人说dp，瞬间就不想写了。现在想想，是在有点不可取。</p><p>K找到了规律，但是卡在了前缀和上。（赛后五分钟想通.jpg）</p><p>感到自己问题很大，甚至快回到起点。</p><h1 id="A-PERFECT-NUMBER-PROBLEM"><a href="#A-PERFECT-NUMBER-PROBLEM" class="headerlink" title="A. PERFECT NUMBER PROBLEM"></a>A. PERFECT NUMBER PROBLEM</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>完数定义：小于N的数的因子的和为N，则称N为完数。</p><p>求前五个完数。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><del>（百度不就好了）</del></p><p>采用类似素数筛的做法，统计因子和。如果因子和等于原数则记下该数。最后复制程序输出直接提交即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">40000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">10</span>], ans_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)</span><br><span class="line">&#123;</span><br><span class="line">num[i]++;</span><br><span class="line"><span class="keyword">if</span> (num[i] == i)</span><br><span class="line">&#123;</span><br><span class="line">ans[ans_num++] = i;</span><br><span class="line"><span class="keyword">if</span> (ans_num == <span class="number">5</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; i * j &lt;= N; j++)</span><br><span class="line">&#123;</span><br><span class="line">num[i * j] += i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans_num; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "6\n28\n496\n8128\n33550336";</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Greedy-HOUHOU"><a href="#B-Greedy-HOUHOU" class="headerlink" title="B. Greedy HOUHOU"></a>B. Greedy HOUHOU</h1><p>待补</p><h1 id="C-Angry-FFF-Party"><a href="#C-Angry-FFF-Party" class="headerlink" title="C. Angry FFF Party"></a>C. Angry FFF Party</h1><p>待补</p><h1 id="D-Match-Stick-Game"><a href="#D-Match-Stick-Game" class="headerlink" title="D. Match Stick Game"></a>D. Match Stick Game</h1><p>待补</p><h1 id="E-Card-Game"><a href="#E-Card-Game" class="headerlink" title="E. Card Game"></a>E. Card Game</h1><p>待补</p><h1 id="F-Information-Transmitting"><a href="#F-Information-Transmitting" class="headerlink" title="F. Information Transmitting"></a>F. Information Transmitting</h1><p>待补</p><h1 id="G-tsy’s-number"><a href="#G-tsy’s-number" class="headerlink" title="G. tsy’s number"></a>G. tsy’s number</h1><p>待补</p><h1 id="H-Coloring-Game"><a href="#H-Coloring-Game" class="headerlink" title="H. Coloring Game"></a>H. Coloring Game</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>现在有$2\times N$的方格。从左上角开始涂方格涂到右下角。（很明显，这两个角必涂）</p><p>可以往八个方向涂色，求方案数。（$mod 10^7+7$）</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于地图是$2\times N$的，很明显，每一列都必涂。</p><p>由于可以斜着走，所以下一列的两个无论当前位置在哪里都可以到达，即每一列都是独立的。</p><p>那么我们思考每一列的情况即可。</p><p>因为第一列和最后一列有一格必涂（左上角和右下角），所以这两列可能的情况数是2。</p><p>其它的列，肯定会涂至少一个。那么就会有三个情况：</p><ul><li>涂上面的一个</li><li>涂下面的一个</li><li>两个格子都涂</li></ul><p>所以对于其它的列，可能的情况数是3。</p><p>由于列独立，所以将每行的情况数乘起来即可($4\times 3^{n-2}$)。使用快速幂即可解决。</p><p>注意$n$为1时要特判一下，否则会RE。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Powq</span><span class="params">(ll n, ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x &amp; <span class="number">1</span>)</span><br><span class="line">res = res * n % mod;</span><br><span class="line">n = n * n % mod;</span><br><span class="line">x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ll ans = Powq(<span class="number">3</span>, n - <span class="number">2</span>);</span><br><span class="line">ans *= <span class="number">4</span>;</span><br><span class="line">ans %= mod;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="I-Max-answer"><a href="#I-Max-answer" class="headerlink" title="I. Max answer"></a>I. Max answer</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定数组，求所有区间中区间最小值乘以区间和的最大值。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p><del>（线段树也可以做）</del></p><p>遍历数组，每次将遍历到的数作为区间最小值。</p><p>然后利用单调栈确定能使得区间最小值为$a[i]$的最大区间。代码中$l[i]$表示在区间$[l[i],i]$中，区间最小值为$a[i]$，$r[i]$表示在区间$[i,r[i]]$中，区间最小值为$a[i]$。</p><p>然后对于前缀和搞一下RMQ。之后对每次循环得到的区间$[l[i],r[i]]$(这是使得区间最小值为$a[i]$的最大区间)，我们有两种情况：</p><blockquote><p>$a[i]&lt;0$：在$[l[i],i]$中找到前缀和最大的值$Max$，在$[i,r[i]]$中找到前缀和最小的值$Min$。$a[i]*(Min-Max)$即为答案。</p><p>$a[i]&lt;0$：在$[l[i],i]$中找到前缀和最小的值$Min$，在$[i,r[i]]$中找到前缀和最大的值$Max$。$a[i]*(Max-Min)$即为答案。</p><p> $a[i]==0$：答案为0。</p></blockquote><p>对所有答案取最大即可。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1e17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">ll sum[maxn], stmx[maxn][<span class="number">23</span>], stmn[maxn][<span class="number">23</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn], l[maxn], r[maxn];</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">askmx</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = log2(r - l + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> max(stmx[l][k], stmx[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">askmn</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = log2(r - l + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> min(stmn[l][k], stmn[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + (ll)a[i];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++) </span><br><span class="line">stmx[i][<span class="number">0</span>] = stmn[i][<span class="number">0</span>] = sum[i];</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n + <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">stmx[i][j] = max(stmx[i][j - <span class="number">1</span>], stmx[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">stmn[i][j] = min(stmn[i][j - <span class="number">1</span>], stmn[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (!sta.empty() &amp;&amp; a[i] &lt;= a[sta.top()]) </span><br><span class="line">sta.pop();</span><br><span class="line"><span class="keyword">if</span> (sta.empty()) </span><br><span class="line">l[i] = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">l[i] = sta.top() + <span class="number">1</span>;</span><br><span class="line">sta.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!sta.empty()) sta.pop();</span><br><span class="line"><span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (!sta.empty() &amp;&amp; a[i] &lt;= a[sta.top()]) </span><br><span class="line">sta.pop();</span><br><span class="line"><span class="keyword">if</span> (sta.empty()) </span><br><span class="line">r[i] = n; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">r[i] = sta.top() - <span class="number">1</span>;</span><br><span class="line">sta.push(i);</span><br><span class="line">&#125;</span><br><span class="line">ll ans = -inf;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ll R = askmn(i, r[i]);</span><br><span class="line">ll L = askmx(l[i] - <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">ans = max(ans, (R - L) * (ll)a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ll R = askmx(i, r[i]);</span><br><span class="line">ll L = askmn(l[i] - <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">ans = max(ans, (R - L) * (ll)a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans = max(ans, <span class="number">0l</span>l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="J-Distance-on-the-tree"><a href="#J-Distance-on-the-tree" class="headerlink" title="J. Distance on the tree"></a>J. Distance on the tree</h1><p>待补</p><h1 id="K-MORE-XOR"><a href="#K-MORE-XOR" class="headerlink" title="K. MORE XOR"></a>K. MORE XOR</h1><p>待补</p><h1 id="L-qiqi’tree"><a href="#L-qiqi’tree" class="headerlink" title="L. qiqi’tree"></a>L. qiqi’tree</h1><p>待补</p><h1 id="M-Subsequence"><a href="#M-Subsequence" class="headerlink" title="M. Subsequence"></a>M. Subsequence</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定字符串$s (length(s)\leq 10^5)$。</p><p>之后给定$N$个待匹配串$x$，问能否在字符串$s$中找到子序列$x$。($N \leq 10^5 ,length(x)\leq 1000$)</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>暴力找时间复杂度是$O(n\times length(s))$，明显会TLE。</p><p>我们可以将字符串$s$的每个字母出现的位置用vector存起来。</p><p>然后对于输入的每一个$x$，我们可以从头遍历利用upper_bound来寻找符合要求的位置并更新即可。</p><p>时间复杂度$O(N\times length(x)\times log_{2} length(s))$。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;pos[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">char</span> x[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%*c"</span>, s);</span><br><span class="line"><span class="keyword">int</span> s_len = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s_len; i++)</span><br><span class="line">&#123;</span><br><span class="line">pos[s[i] - <span class="string">'a'</span>].push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%*c"</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%*c"</span>, x);</span><br><span class="line"><span class="keyword">int</span> x_len = <span class="built_in">strlen</span>(x);</span><br><span class="line"><span class="keyword">int</span> now_pos;</span><br><span class="line"><span class="keyword">bool</span> print = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (pos[x[<span class="number">0</span>] - <span class="string">'a'</span>].empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">now_pos = pos[x[<span class="number">0</span>] - <span class="string">'a'</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; x_len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ch_pos = x[i] - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span> (pos[ch_pos].empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">print = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ppos = upper_bound(pos[ch_pos].begin(), pos[ch_pos].end(), now_pos) - pos[ch_pos].begin();</span><br><span class="line"><span class="keyword">if</span> (ppos &lt; pos[ch_pos].size())</span><br><span class="line">now_pos = pos[ch_pos][ppos];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">print = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!print)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;https://www.jisuanke.com/contest/2290?view=challenges&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jisuanke.com/contest/2290?view=challenges&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计蒜客" scheme="http://FZ-c.github.io/categories/%E8%AE%A1%E8%92%9C%E5%AE%A2/"/>
    
    
      <category term="ACM" scheme="http://FZ-c.github.io/tags/ACM/"/>
    
      <category term="icpc" scheme="http://FZ-c.github.io/tags/icpc/"/>
    
  </entry>
  
  <entry>
    <title>计算几何基础I</title>
    <link href="http://FZ-c.github.io/2019/04/23/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80I/"/>
    <id>http://FZ-c.github.io/2019/04/23/计算几何基础I/</id>
    <published>2019-04-23T08:46:06.802Z</published>
    <updated>2019-04-24T10:41:49.420Z</updated>
    
    <content type="html"><![CDATA[<p>为后面的点线面关系及凸包等做铺垫。</p><a id="more"></a><h1 id="准备知识及注意点"><a href="#准备知识及注意点" class="headerlink" title="准备知识及注意点"></a>准备知识及注意点</h1><h2 id="常用头文件-amp-常量-amp-函数"><a href="#常用头文件-amp-常量-amp-函数" class="headerlink" title="常用头文件&amp;常量&amp;函数"></a>常用头文件&amp;常量&amp;函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inf = <span class="number">1e100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sign</span><span class="params">(<span class="keyword">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; -eps ? <span class="number">-1</span> : a &gt; eps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> num = <span class="number">1.49999</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f %d %d %d\n"</span>, num, <span class="built_in">floor</span>(num), <span class="built_in">ceil</span>(num), round(num));</span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="误差问题"><a href="#误差问题" class="headerlink" title="误差问题"></a>误差问题</h2><h3 id="浮点误差"><a href="#浮点误差" class="headerlink" title="浮点误差"></a>浮点误差</h3><p>计算几何中double类型用得很多。<strong>不要用float！</strong>float精度太小。</p><h3 id="计算误差"><a href="#计算误差" class="headerlink" title="计算误差"></a>计算误差</h3><p>尽量不用三角函数或者除法或者开方等等可能会产生小数的运算。</p><p>例如：</p><script type="math/tex; mode=display">4*\pi*\left( \frac{r}{2} \right) ^2</script><p>化简一下变成计算：$\pi r^2$，又方便又避免因为计算产生的精度问题造成WA。</p><h3 id="判断相等"><a href="#判断相等" class="headerlink" title="判断相等"></a>判断相等</h3><p><strong>注意上面的sign函数，不要直接用==判断相等！</strong></p><p>在此不再赘述</p><h3 id="反三角函数"><a href="#反三角函数" class="headerlink" title="反三角函数"></a>反三角函数</h3><p>使用反三角函数时记得看清楚定义域。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> x = <span class="number">1.0000001</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.6lf"</span>, <span class="built_in">acos</span>(x));<span class="comment">//WA or RE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="点与向量"><a href="#点与向量" class="headerlink" title="点与向量"></a>点与向量</h1><h2 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h2><h3 id="点的定义"><a href="#点的定义" class="headerlink" title="点的定义"></a>点的定义</h3><p>一个点可以用一个结构体存储一个点。</p><p>$N$维的点就用$N$个实数来标记即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> x, y;</span><br><span class="line">&#125;Point;</span><br></pre></td></tr></table></figure><h3 id="向量的定义"><a href="#向量的定义" class="headerlink" title="向量的定义"></a>向量的定义</h3><p>向量就是有方向的线段。我们记$A(a_1,b_1) ,B(a_2,b_2)$，则$\vec{AB}=(a_2-a_1,b_2-b_1)$。</p><p>那么我们也可以使用前面点的存储来存储向量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br></pre></td></tr></table></figure><h2 id="相关运算"><a href="#相关运算" class="headerlink" title="相关运算"></a>相关运算</h2><p>$\vec{a}=\vec {AB}=\{a_1,b_1\},\vec{b}=\vec{CD}=\{a_2,b_2\}$，后不再赘述。</p><h3 id="基础运算"><a href="#基础运算" class="headerlink" title="基础运算"></a>基础运算</h3><p>向量加法：$\vec{a}+\vec{b}=\{a_1+a_2,b_1+b_2\}$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector <span class="keyword">operator</span> + (Point A, Point B) &#123;</span><br><span class="line"><span class="keyword">return</span> Vector(A.x + B.x, A.y + B.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向量减法：$\vec{a}-\vec{b}=\{a_1-a_2,b_1-b_2\}$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector <span class="keyword">operator</span> - (Point A, Point B) &#123;</span><br><span class="line"><span class="keyword">return</span> Vector(A.x - B.x, A.y - B.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向量乘法（数乘）：$k\vec{a}=\{ka_1,kb_1\}$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector <span class="keyword">operator</span> * (Point A, <span class="keyword">double</span> k) &#123;</span><br><span class="line"><span class="keyword">return</span> Vector(A.x * k, A.y * k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向量除法：$\vec{a}/k=\{a_1/k,b_1/k\}$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector <span class="keyword">operator</span> / (Point A, <span class="keyword">double</span> k) &#123;</span><br><span class="line"><span class="keyword">return</span> Vector(A.x / k, A.y / k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数量积"><a href="#数量积" class="headerlink" title="数量积"></a>数量积</h3><p>又叫点积，定义：</p><script type="math/tex; mode=display">\vec{a} \cdot \vec{b}=\mid\vec{a}\mid\mid\vec{b}\mid cos\theta=a_1a_2+b_1b_2</script><p>满足的运算律有：</p><ul><li><p>分配律：$\vec{a}\cdot(\vec{b}+\vec{c})=\vec{a}\cdot\vec{b}+\vec{a}\cdot\vec{c}$</p></li><li><p>结合律：$(m\vec{a})\cdot\vec{b}=m(\vec{a}\cdot\vec{b})=\vec{a}\cdot(m\vec{b})$</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dot</span><span class="params">(Vector A, Vector B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> A.x* B.x + A.y * B.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向量积"><a href="#向量积" class="headerlink" title="向量积"></a>向量积</h3><p>又叫外积、叉积，定义：</p><script type="math/tex; mode=display">\mid\vec{a}\times\vec{b}\mid=\mid\vec{a}\mid*\mid\vec{b}\mid*sin\theta=a_1*b_2-a_2*b_1</script><p>向量积的结果的方向与$\vec{a}$和$\vec{b}$垂直且满足右手法则。</p><p>满足的运算律有：</p><ul><li>反交换律：$\vec{a}\times\vec{b}=-\vec{b}\times\vec{a}$</li><li>分配律：$\vec{a}\times(\vec{b}+\vec{c})=\vec{a}\times\vec{b}+\vec{a}\times\vec{c}$</li><li>结合律：$(m\vec{a})\times\vec{b}=m*(\vec{a}\times\vec{b})=\vec{a}\times(m\vec{b})$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cross</span><span class="params">(Vector A, Vector B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> A.x* B.y - A.y * B.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用排序方法"><a href="#常用排序方法" class="headerlink" title="常用排序方法"></a>常用排序方法</h2><h3 id="水平序"><a href="#水平序" class="headerlink" title="水平序"></a>水平序</h3><p>即按照横坐标升序排列，若横坐标相同，则按照纵坐标升序排列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b) &#123;</span><br><span class="line"><span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此排序方法将在Andrew算法中用到。</p><h3 id="极角排序"><a href="#极角排序" class="headerlink" title="极角排序"></a>极角排序</h3><p>相关定义：</p><p>在平面中取一个定点$O$，称为极点。由极点引一条射线$Ox$，称为极轴。选定一个长度单位和角度的正方向。（这样就建立了一个极坐标系）</p><p>对于平面内任意一点$M$，我们可以用极坐标$(\rho,\theta)$来表示。其中，$\rho$表示线段$OM$的长度，$\theta$表示$Ox$与$OM$的夹角角度。这里$\rho$称为点$M$的极径，$\theta$称为点$M$的极角。</p><p>那么极角排序就是将平面上的点按照某一个选定的中心点以顺（逆）时针排序。（以下以中心点为原点排序）</p><p>极角计算：</p><ul><li>方法1：利用atan2()函数</li></ul><p><strong>atan2()函数声明</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意参数y在前，x在后</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan2</span><span class="params">(<span class="keyword">double</span> y, <span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>为什么不使用atan()函数呢</strong></p><p>atan()函数声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p>atan()函数的参数是一个角度值，而atan2()函数的参数是一个点坐标。</p><p>容易得到：atan2(y,x)等价于atan(y/x)。</p><p>我们知道，$arctan(x)$的值域是$(-\pi/2,\pi/2)$。那么， atan()函数的返回值的范围也是在$(-\pi/2,\pi/2)$中。</p><p>但是，atan2的返回值却与坐标相关。见下图：</p><p><img src="/2019/04/23/计算几何基础I/03087bf40ad162d9d8bea3ff16dfa9ec8b13cd85.jpg" alt></p><p>这时atan2()函数的值域就是$(-\pi,\pi)$了，点的极角也就确定了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">atan2</span>(a.y, a.x) != <span class="built_in">atan2</span>(b.y, b.x))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">atan2</span>(a.y, a.x) &lt; <span class="built_in">atan2</span>(b.y, b.x);</span><br><span class="line"><span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法2：利用叉积排序</li></ul><p>对于任意两个点$A$和$B$，我们可以比较$\vec{OA}$与$\vec{OB}$的叉乘的正负情况来判定方向。</p><p>若叉乘为0，则两向量平行或者重合；若叉乘小于0，则$\vec{OA}$在$\vec{OB}$的逆时针方向；反之在顺时针方向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逆时针排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Cross(a, b) == <span class="number">0</span> ? a.x &lt; b.x : Cross(a, b)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h2><ul><li>求模（即长度）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Length</span><span class="params">(Vector x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(Dot(x, x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>计算两向量夹角（利用叉积）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Angle</span><span class="params">(Vector x, Vector y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">acos</span>(Dot(x, y) / Length(x) / Length(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>计算两向量构成的平行四边形面积</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Area</span><span class="params">(Point a, Point b, Point c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Cross(b - a, c - a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>向量逆时针旋转某角度</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector <span class="title">Rotate</span><span class="params">(Vector v, <span class="keyword">double</span> rad)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Vector(v.x * <span class="built_in">cos</span>(rad) - v.y * <span class="built_in">sin</span>(rad), v.x * <span class="built_in">sin</span>(rad) + v.y * <span class="built_in">cos</span>(rad));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为后面的点线面关系及凸包等做铺垫。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://FZ-c.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://FZ-c.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="集训队" scheme="http://FZ-c.github.io/tags/%E9%9B%86%E8%AE%AD%E9%98%9F/"/>
    
      <category term="计算几何" scheme="http://FZ-c.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #553(div2) </title>
    <link href="http://FZ-c.github.io/2019/04/19/Codeforces-Round-553-div2/"/>
    <id>http://FZ-c.github.io/2019/04/19/Codeforces-Round-553-div2/</id>
    <published>2019-04-19T03:36:45.000Z</published>
    <updated>2019-04-25T05:16:41.383Z</updated>
    
    <content type="html"><![CDATA[<p>题目列表：<a href="https://codeforces.com/contest/1151/problems" target="_blank" rel="noopener">https://codeforces.com/contest/1151/problems</a></p><p>传送门：<a href="https://codeforces.com/contest/1151" target="_blank" rel="noopener">https://codeforces.com/contest/1151</a></p><a id="more"></a><p>这次的cf真的很自闭。</p><p>半小时出A题了解一下？<del>（我写代码像cxk！）</del></p><p>脑袋是塞钢筋了吧……补题补题QAQ</p><h1 id="A-Maxim-and-Biology"><a href="#A-Maxim-and-Biology" class="headerlink" title="A. Maxim and Biology"></a>A. Maxim and Biology</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个字符串s,问最少多少次操作可以使字符串中出现一个”ACTG”。</p><p>操作即对某个字符+1或者-1，’Z’+1=’A’，反之同理。($4 \leq |s| \leq 50$)</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>考虑一下这样的一个串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></span><br></pre></td></tr></table></figure><p>我们记$p=”ACTG”$，我们标记$s[i+j]$的位置$poss=s[i+j]-‘A’+26$（即上面的字符串中的中间段）。那么我们可以得到：$ans=min(abs(poss-p[i]-‘A’),abs(poss-p[i]-‘A’+26),abs(poss-p[i]-‘A’+52)$。</p><p>遍历一下取最小就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">string</span> pp = <span class="string">"ACTG"</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> poss = s[i + j] - <span class="string">'A'</span> + <span class="number">26</span>;</span><br><span class="line"><span class="keyword">int</span> pos1 = pp[j] - <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">int</span> pos2 = pp[j] - <span class="string">'A'</span> + <span class="number">52</span>;</span><br><span class="line"><span class="keyword">int</span> pos3 = pp[j] - <span class="string">'A'</span> + <span class="number">26</span>;</span><br><span class="line"><span class="keyword">int</span> anss = min(poss - pos1, pos2 - poss);</span><br><span class="line">anss = min(anss, <span class="built_in">abs</span>(pos3 - poss));</span><br><span class="line">x += anss;</span><br><span class="line">&#125;</span><br><span class="line">ans = min(ans, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Dima-and-a-Bad-XOR"><a href="#B-Dima-and-a-Bad-XOR" class="headerlink" title="B. Dima and a Bad XOR"></a>B. Dima and a Bad XOR</h1><p>待补</p><h1 id="C-Problem-for-Nazar"><a href="#C-Problem-for-Nazar" class="headerlink" title="C. Problem for Nazar"></a>C. Problem for Nazar</h1><p>待补</p><h1 id="D-Stas-and-the-Queue-at-the-Buffet"><a href="#D-Stas-and-the-Queue-at-the-Buffet" class="headerlink" title="D.Stas and the Queue at the Buffet"></a>D.Stas and the Queue at the Buffet</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定$n$组键值对$\{a_i,b_i\}$，对于每个键值对的位置$pos$，计算下式的最小值。</p><script type="math/tex; mode=display">\sum_{pos=1}^{n}{a_i*(pos-1)+b_i*(n-pos)}</script><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>我们考虑一个键值对$\{a,b\}$，它在数组中的位置如果向后移动一位，对答案的影响是：</p><script type="math/tex; mode=display">\Delta ans=a*(pos-1)+b*(n-pos)-a*((pos+1)-1)+b*(n-(pos+1))=a-b</script><p>那么我们对键值按照$a-b$的大小进行排序就可以得出答案了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;ll, ll&gt; a, pair &lt; ll,ll&gt; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.first - a.second &gt; b.first - b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;ll, ll&gt; num[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num[i].first &gt;&gt; num[i].second;</span><br><span class="line">sort(num + <span class="number">1</span>, num + <span class="number">1</span> + n, cmp);</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">&#123;</span><br><span class="line">res += num[i].second * (n - i) + (i - <span class="number">1</span>) * num[i].first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-Number-of-Components"><a href="#E-Number-of-Components" class="headerlink" title="E.Number of Components"></a>E.Number of Components</h1><p>待补</p><h1 id="F-Sonya-and-Informatics"><a href="#F-Sonya-and-Informatics" class="headerlink" title="F.Sonya and Informatics"></a>F.Sonya and Informatics</h1><p>待补</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目列表：&lt;a href=&quot;https://codeforces.com/contest/1151/problems&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codeforces.com/contest/1151/problems&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://codeforces.com/contest/1151&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codeforces.com/contest/1151&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Codeforces" scheme="http://FZ-c.github.io/categories/Codeforces/"/>
    
    
      <category term="Codeforces" scheme="http://FZ-c.github.io/tags/Codeforces/"/>
    
      <category term="div2" scheme="http://FZ-c.github.io/tags/div2/"/>
    
  </entry>
  
  <entry>
    <title>2019省赛预备-Practice Round 1</title>
    <link href="http://FZ-c.github.io/2019/04/18/2019%E7%9C%81%E8%B5%9B%E9%A2%84%E5%A4%87-Practice-Round-1/"/>
    <id>http://FZ-c.github.io/2019/04/18/2019省赛预备-Practice-Round-1/</id>
    <published>2019-04-18T08:39:30.000Z</published>
    <updated>2019-04-29T14:28:11.058Z</updated>
    
    <content type="html"><![CDATA[<p>题目列表：<a href="https://codeforces.com/gym/242928/attachments/download/7292/statements.pdf" target="_blank" rel="noopener">https://codeforces.com/gym/242928/attachments/download/7292/statements.pdf</a></p><p>传送门：<a href="https://codeforces.com/gym/242928" target="_blank" rel="noopener">https://codeforces.com/gym/242928</a></p><a id="more"></a><p>第一次在cf的gym上开比赛，感慨良多。<del>（哇cf功能有点太多了吧tql！）</del></p><p>这一次选了这一套题（<a href="https://codeforces.com/gym/101853" target="_blank" rel="noopener">https://codeforces.com/gym/101853</a>，传送门进不去可以在这里进去，因为传送门是要我邀请才能进去的），难度二星。算是简单的。</p><p>一开始抓了A题过来看，嗯~是个简单题？然后就很自信地写了，然后就很正常的WA了。</p><p>皱了皱眉头，改了一下，emmmm，继续WA。</p><p>算了，先弃掉，看了H题和I题，都是很简单的计算题。都1A了。</p><p>队友干了F题和D题，我再干掉J题。似乎剩下的简单题就只有A了。</p><p>于是回头讨论A怎么办，发现0要特殊处理。队友再交了两发WA之后终于过了。<del>（再次证明我是个傻逼）</del></p><p>最后看了一下G并讨论了一大波，经另一个队的大佬提醒是BSGS。便抄起了板子，然后发现WA了。赛后才知道是扩展BSGS。<del>（哭死）</del></p><p><del>K题真的是L1-08警告</del></p><h1 id="A-Zero-Array"><a href="#A-Zero-Array" class="headerlink" title="A Zero Array"></a>A Zero Array</h1><p>待补</p><h1 id="B-New-Assignment"><a href="#B-New-Assignment" class="headerlink" title="B New Assignment"></a>B New Assignment</h1><p>待补</p><h1 id="C-Intersections"><a href="#C-Intersections" class="headerlink" title="C Intersections"></a>C Intersections</h1><p>待补</p><h1 id="D-Balloons"><a href="#D-Balloons" class="headerlink" title="D Balloons"></a>D Balloons</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有$T$个有$n$道题目的比赛，每解决一个题目会有一个气球。现在对于每场比赛给出每道题目AC的次数，求你能拿到的气球个数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><del>这真的傻逼题。</del></p><p>直接计数不是0的数个数就好了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line"><span class="keyword">if</span> (num)ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-Maximum-Sum"><a href="#E-Maximum-Sum" class="headerlink" title="E Maximum Sum"></a>E Maximum Sum</h1><p>待补</p><h1 id="F-Working-Time"><a href="#F-Working-Time" class="headerlink" title="F Working Time"></a>F Working Time</h1><p>待补</p><h1 id="G-Hard-Equation"><a href="#G-Hard-Equation" class="headerlink" title="G Hard Equation"></a>G Hard Equation</h1><p>待补</p><h1 id="H-Cube"><a href="#H-Cube" class="headerlink" title="H Cube"></a>H Cube</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>已知正立方体的表面积，求正方体棱长。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><del>（初中数学）</del></p><p>表面积 $S=6x^2$，棱长 $x=\sqrt{S/6}$。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">x /= <span class="number">6</span>;</span><br><span class="line">x = <span class="built_in">sqrt</span>(x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="I-Circles"><a href="#I-Circles" class="headerlink" title="I Circles"></a>I Circles</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>如下图，先以点$c$为圆心画一个直径为$d$的圆，然后再画一个内接正方形。再以正方形四条边为直径画一个圆。求阴影部分的面积。</p><p><img src="/2019/04/18/2019省赛预备-Practice-Round-1/6005b8a93fccb43ec514b94d93997bea36464de3.png" alt></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p><del>瞎鸡儿算就对了</del></p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a, b, d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>, (<span class="keyword">double</span>)d * d / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="J-Smallest-Difference"><a href="#J-Smallest-Difference" class="headerlink" title="J Smallest Difference"></a>J Smallest Difference</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个数组，让你从数组中挑一些数使得所挑的数中任意两个数的差都不大于1。求你能跳的数的最大个数。</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>统计各个数字出现的次数，找到相邻两个数出现次数之和的最大值即可。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">num[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num[i] + num[i + <span class="number">1</span>] &gt; ans)</span><br><span class="line">ans = num[i] + num[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="K-Citations"><a href="#K-Citations" class="headerlink" title="K Citations"></a>K Citations</h1><p>待补</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目列表：&lt;a href=&quot;https://codeforces.com/gym/242928/attachments/download/7292/statements.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codeforces.com/gym/242928/attachments/download/7292/statements.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://codeforces.com/gym/242928&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codeforces.com/gym/242928&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Codeforces" scheme="http://FZ-c.github.io/categories/Codeforces/"/>
    
    
      <category term="ACM" scheme="http://FZ-c.github.io/tags/ACM/"/>
    
      <category term="Codeforces" scheme="http://FZ-c.github.io/tags/Codeforces/"/>
    
      <category term="ccpc" scheme="http://FZ-c.github.io/tags/ccpc/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #552（Div3）</title>
    <link href="http://FZ-c.github.io/2019/04/17/Codeforces-Round-552(Div3)/"/>
    <id>http://FZ-c.github.io/2019/04/17/Codeforces-Round-552(Div3)/</id>
    <published>2019-04-16T20:39:53.749Z</published>
    <updated>2019-04-25T06:45:14.820Z</updated>
    
    <content type="html"><![CDATA[<p>题目列表：<a href="https://codeforces.com/contest/1154/problems" target="_blank" rel="noopener">https://codeforces.com/contest/1154/problems</a></p><p>传送门：<a href="https://codeforces.com/contest/1154" target="_blank" rel="noopener">https://codeforces.com/contest/1154</a></p><a id="more"></a><p>这次CF的难度还是比较和谐的<del>(后背一凉)</del> 。</p><h2 id="A-Restoring-Three-Numbers"><a href="#A-Restoring-Three-Numbers" class="headerlink" title="A. Restoring Three Numbers"></a>A. Restoring Three Numbers</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出$a+b ,a+c ,b+c ,a+b+c$ 的值（可能不按顺序，$2 \leq x_i \leq 10^9$），求正整数$a,b,c$的值。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很明显，$a+b+c$肯定是最大的，将这个最大值依次减去另外三个值就可以得到这三个数。</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">sort(num, num + <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num[<span class="number">3</span>] - num[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Make-Them-Equal"><a href="#B-Make-Them-Equal" class="headerlink" title="B. Make Them Equal"></a>B. Make Them Equal</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个数组（数组不空且元素个数不大于100，元素值为正整数且不大于100），现在对数组的每一个元素都可以实施一次操作：</p><ul><li>该元素$+D$</li><li>该元素$-D$</li></ul><p>现在要使数组所有元素相等，求能完成操作的非负整数$D$的最小值，若不能完成，输出-1。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先，去掉重复数字是必要的。（使用set）</p><p>去重之后，对set的大小进行分类讨论：</p><blockquote><p>若set大小为1，则 $D=0$ 。（元素无需变化）</p><p>若set大小为2：</p><blockquote><p>若两个元素的均值为整数：$D=(num[1]+num[0])/2-num[0]$（即他们俩都转化为均值）</p><p>若两个元素的均值不为整数：$D=num[1]-num[0]$</p></blockquote><p>若set大小为3：</p><blockquote><p>判断中间值与最大值最小值的差是否相等：</p><p>相等：$D=num[1]-num[0]$ （即中间值减较小值）</p><p>不相等：$-1$</p></blockquote><p>若set大小为其他情况：$-1$</p></blockquote><h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;num;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">num.insert(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num.size() == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ppp[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator sit = num.begin(); sit != num.end(); sit++, i++)</span><br><span class="line">&#123;</span><br><span class="line">ppp[i] = *sit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> xx = ppp[<span class="number">1</span>] - ppp[<span class="number">0</span>], yy = ppp[<span class="number">2</span>] - ppp[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (xx == yy)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; xx;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num.size() == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ppp[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator sit = num.begin(); sit != num.end(); sit++, i++)</span><br><span class="line">&#123;</span><br><span class="line">ppp[i] = *sit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((ppp[<span class="number">0</span>] + ppp[<span class="number">1</span>]) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (ppp[<span class="number">0</span>] + ppp[<span class="number">1</span>]) / <span class="number">2</span> - ppp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ppp[<span class="number">1</span>] - ppp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num.size() == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Gourmet-Cat"><a href="#C-Gourmet-Cat" class="headerlink" title="C. Gourmet Cat"></a>C. Gourmet Cat</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>你有只猫，周一、四、日吃鱼，周二、六吃兔肉。其余时间吃鸡肉。现在你要去旅行，且你准备了 $a$ 份鱼、$b$ 份兔肉、$c$ 份鸡肉在家里。求你在某天出门后这只猫能按要求吃的的最大天数。（这个天数跟你周几出门有关）。（$1 \leq a,b,c \leq 7*10^8$）</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以先将能吃完整一周的粮食去除，去除之后再模拟7种出门的情况取最大值即可。</p><h3 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录每种粮食的个数</span></span><br><span class="line">ll num[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//记录每天（下标1-7）吃的粮食种类，与上对应</span></span><br><span class="line"><span class="keyword">int</span> day[<span class="number">8</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//除去能吃一周的粮食，ans1为能吃的完整周数</span></span><br><span class="line">ll ans1 = num[<span class="number">0</span>] / <span class="number">3</span>;</span><br><span class="line">ans1 = min(ans1, num[<span class="number">1</span>] / <span class="number">2</span>);</span><br><span class="line">ans1 = min(ans1, num[<span class="number">2</span>] / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">num[i] -= ans1 * (i == <span class="number">0</span> ? <span class="number">3</span> : <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">ll ans2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">ll ppp[<span class="number">3</span>];</span><br><span class="line">ll aans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">ppp[j] = num[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i;; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">8</span>)</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (ppp[day[j]])</span><br><span class="line">&#123;</span><br><span class="line">ppp[day[j]]--;</span><br><span class="line">aans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans2 = max(ans2, aans);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//注意天数ans1要乘7</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans1 * <span class="number">7</span> + ans2;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Walking-Robot"><a href="#D-Walking-Robot" class="headerlink" title="D. Walking Robot"></a>D. Walking Robot</h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>有个机器人在 $0$ 位置处，现在要走到位置 $n$ 。机器人现在有一个电池容量为 $b$ ，还有一个蓄电池容量为 $a$（一开始都是满的）。数组 $s$ 的元素值代表此处有没有光照。机器人走一格耗1电量，如果<strong>机器人使用电池行走并在太阳下时</strong>，蓄电池电量+1（但不能超过容量）。求最远的行走距离。（$1 \leq n,b,a \leq 2*10^5 , 0 \leq s_i\leq 1$）</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>同样是一个分类讨论的问题：</p><blockquote><p>电池和蓄电池均无电：结束</p><p>在阳光下：</p><blockquote><p>电池有电：电池电量$-1$，蓄电池电量$+1$。</p><p>电池无电：蓄电池电量$-1$。（切记这里无法充电）</p></blockquote><p>不在阳光下：</p><blockquote><p>蓄电池有电：蓄电池电量$-1$。</p><p>蓄电池无电：电池电量$-1$。</p></blockquote></blockquote><h3 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">bool</span> sun[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, b, a;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; b &gt;&gt; a;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; sun[i];</span><br><span class="line"><span class="comment">// a 充电</span></span><br><span class="line">    <span class="comment">//now_a now_b 为当前电池电量</span></span><br><span class="line"><span class="keyword">int</span> now_a = a;</span><br><span class="line"><span class="keyword">int</span> now_b = b;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (now_a == <span class="number">0</span> &amp;&amp; now_b == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sun[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (now_b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (now_a &lt; a)</span><br><span class="line">&#123;</span><br><span class="line">now_b--;</span><br><span class="line">now_a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">now_a--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">now_a--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (now_a)</span><br><span class="line">now_a--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">now_b--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Two-Teams"><a href="#E-Two-Teams" class="headerlink" title="E. Two Teams"></a>E. Two Teams</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有两个教练来选人，第一个人先选。给定一排人的技巧值$a_i$。</p><p>两个人选的策略是：找到还没被选的最大的一个，然后再选择它左边 $k$ 个和右边 $k$ 个。每次选完之后被选中的人出列。</p><p>他们轮流选直到全部选完。输出原数列中的每个人分别都被第几个人选了。</p><p>($1 \leq k \leq n \leq 2*10^5 , 1 \leq a_i \leq n$，保证技巧值唯一)</p><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p><del>这道题差点写到心态爆炸</del> </p><p>由于存在出列的操作，我们需要将数据存储在链表上。（方便删除被选中的结点）</p><p>再弄一个pair数组，存储数据和结点指针。对数组排序可以快速得到当前的最大值并找到该结点。</p><p>最后按照题目模拟过程删除结点记录1或者2最后输出即可。</p><p>这道题代码比较丑QAQ 。</p><p>这道题貌似可以用并查集做？等待补充。</p><h3 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">pointer</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">pointer sub;</span><br><span class="line">pointer pre;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> pointer Linklist;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, pointer&gt;mmax[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>, pointer&gt;a, pair&lt;<span class="keyword">int</span>, pointer&gt;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delnode</span><span class="params">(pointer p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pointer pre = p-&gt;pre;</span><br><span class="line">pointer sub = p-&gt;sub;</span><br><span class="line"><span class="keyword">if</span>(pre!=<span class="literal">NULL</span>)</span><br><span class="line">pre-&gt;sub = sub;</span><br><span class="line"><span class="keyword">if</span>(sub!=<span class="literal">NULL</span>)</span><br><span class="line">sub-&gt;pre = pre;</span><br><span class="line">    <span class="comment">//标记该结点已被删除</span></span><br><span class="line">p-&gt;data = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">Linklist l = <span class="keyword">new</span> node;</span><br><span class="line">    <span class="comment">//头结点保存的是链表结点个数</span></span><br><span class="line">l-&gt;data = n;</span><br><span class="line">l-&gt;pre = l-&gt;sub = <span class="literal">NULL</span>;</span><br><span class="line">pointer p = l;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">pointer xxx = <span class="keyword">new</span> node;</span><br><span class="line">mmax[i] = make_pair(x, xxx);</span><br><span class="line">xxx-&gt;data = x;</span><br><span class="line">xxx-&gt;id = i;</span><br><span class="line">xxx-&gt;sub = p-&gt;sub;</span><br><span class="line">xxx-&gt;pre = p;</span><br><span class="line">p-&gt;sub = xxx;</span><br><span class="line">p = p-&gt;sub;</span><br><span class="line">&#125;</span><br><span class="line">sort(mmax, mmax + n, cmp);</span><br><span class="line">    <span class="comment">//now为当前选择的人 0表示第一个人 1表示第二个人</span></span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">pointer ppp = mmax[i].second;</span><br><span class="line"><span class="keyword">if</span> (ppp-&gt;data == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//若未被选</span></span><br><span class="line"><span class="keyword">if</span> (ans[ppp-&gt;id] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans[ppp-&gt;id] = now + <span class="number">1</span>;</span><br><span class="line">pointer pre = ppp-&gt;pre;</span><br><span class="line">pointer sub = ppp-&gt;sub;</span><br><span class="line">delnode(ppp);</span><br><span class="line">l-&gt;data--;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = k; p &gt; <span class="number">0</span> &amp;&amp; pre != <span class="literal">NULL</span> &amp;&amp; pre != l; p--)</span><br><span class="line">&#123;</span><br><span class="line">ans[pre-&gt;id] = now + <span class="number">1</span>;</span><br><span class="line">                 <span class="comment">//保存当前结点的前驱后删除结点</span></span><br><span class="line">pointer q = pre-&gt;pre;</span><br><span class="line">delnode(pre);</span><br><span class="line">pre = q;</span><br><span class="line">l-&gt;data--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = k; p &gt; <span class="number">0</span> &amp;&amp; sub != <span class="literal">NULL</span>; p--)</span><br><span class="line">&#123;</span><br><span class="line">ans[sub-&gt;id] = now + <span class="number">1</span>;</span><br><span class="line">                 <span class="comment">//保存当前结点的后继后删除结点</span></span><br><span class="line">pointer q = sub-&gt;sub;</span><br><span class="line">delnode(sub);</span><br><span class="line">sub = q;</span><br><span class="line">l-&gt;data--;</span><br><span class="line">&#125;</span><br><span class="line">now = <span class="number">1</span> - now;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//若数组元素个数为0</span></span><br><span class="line"><span class="keyword">if</span> (l-&gt;data == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-Shovels-Shop"><a href="#F-Shovels-Shop" class="headerlink" title="F. Shovels Shop"></a>F. Shovels Shop</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>商店内有 $n$ 把铲子售卖，价格分别为 $a_i$ ，而你现在要买 $k$ 把铲子。每把铲子你只能买一次。</p><script type="math/tex; mode=display">1 \leq n,m \leq2*10^5\ 1 \leq k \leq min(n,2000)\ 1 \leq a_i \leq 2*10^5</script><p>这个商店有 $m$ 个优惠：若一次购买 $x_i$ 把铲子，那么这 $x_i$ 中较便宜的前 $y_i$ 把铲子免费。</p><p>你可以分多次购买 $k$ 把铲子，每次购买最多只能享受一个优惠，一个优惠可以享受多次。</p><p>求买 $k$ 把铲子的最小花费。（$1 \leq y_i \leq x_i \leq n$）</p><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p><del>完全背包好题</del></p><p>对于输入的铲子价格进行排序。（购买肯定选择最便宜的 $k$ 把铲子）</p><p>然后从买1把铲子到 $k$ 把铲子，对每种情况枚举所有优惠取最小。</p><p>这里需要使用前缀和来获得没有被优惠（即免费）的铲子的花费。</p><p><img src="/2019/04/17/Codeforces-Round-552(Div3)/div3-F.jpg" alt="div3-F"></p><p>假设上图是进行到中间过程的情景。当前是购买 $i$ 把铲子的情况，假设当前可用的优惠之一是 $youhui[j]$。（它是一个pair数据，$first$ 是题目中 $x_i$ ，$second$ 是题目中 $y_i$。</p><p>我们记前缀和数组名字是 $psum$。即 $psum[i]$ 的值为前 $i$ 个铲子的价格和。</p><p>那么我们可以知道，使用该优惠后的总花费为 $dp[i-youhui[j].first]+I$ 的价值。我们可以使用前缀和来求得$I$的价值。</p><p>边看代码的式子和图示，我想你会明白的。</p><h3 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ll num[<span class="number">200010</span>];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;youhui[<span class="number">200010</span>];</span><br><span class="line">ll dp[<span class="number">200010</span>];</span><br><span class="line">ll psum[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">sort(num, num + n);</span><br><span class="line"><span class="comment">//前缀和</span></span><br><span class="line">psum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">psum[i] = psum[i - <span class="number">1</span>] + num[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; youhui[i].first &gt;&gt; youhui[i].second;</span><br><span class="line"><span class="comment">//只买一个不优惠</span></span><br><span class="line">youhui[m].first = <span class="number">1</span>;</span><br><span class="line">youhui[m].second = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">dp[i] = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= youhui[j].first)</span><br><span class="line">&#123;</span><br><span class="line">ll x = dp[i - youhui[j].first] + psum[i] - psum[i - youhui[j].first + youhui[j].second];</span><br><span class="line"><span class="keyword">if</span> (x &lt; dp[i])</span><br><span class="line">dp[i] = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[k];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-Minimum-Possible-LCM"><a href="#G-Minimum-Possible-LCM" class="headerlink" title="G. Minimum Possible LCM"></a>G. Minimum Possible LCM</h2><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定数组，求其中 $lcm(a_i,a_j)$ 的最小的位置 $i$ 和 $j$ 。($2 \leq n \leq 10^6 ,1 \leq a_i \leq 10^7$)</p><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>类似欧拉筛的想法，枚举最大公因子找到是它的最小倍数的两个数。找到后求 $lcm$ 保存最小值即可。</p><p>代码还能改进，待更新。</p><h3 id="参考代码-6"><a href="#参考代码-6" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">ll vis[<span class="number">10000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll ppp = <span class="number">1e18</span>;</span><br><span class="line">pair&lt;ll, ll&gt;ans;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">ll max_num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">max_num = max(max_num, x);</span><br><span class="line"><span class="keyword">if</span> (vis[x])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; ppp)</span><br><span class="line">&#123;</span><br><span class="line">ans.first = vis[x];</span><br><span class="line">ans.second = i;</span><br><span class="line">ppp = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= max_num; i++)</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;ll, ll&gt;aans;</span><br><span class="line">aans.first = aans.second = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (ll j = i; j &lt;= max_num; j += i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (aans.first == <span class="number">-1</span>)</span><br><span class="line">aans.first = j;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">aans.second = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (aans.second != <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (aans.second != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ll Max = aans.first * aans.second / i;</span><br><span class="line"><span class="keyword">if</span> (Max &lt; ppp)</span><br><span class="line">&#123;</span><br><span class="line">ppp = Max;</span><br><span class="line">ans.first = vis[aans.first];</span><br><span class="line">ans.second = vis[aans.second];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans.first &gt; ans.second)</span><br><span class="line">swap(ans.first, ans.second);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%I64d %I64d"</span>, ans.first, ans.second);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目列表：&lt;a href=&quot;https://codeforces.com/contest/1154/problems&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codeforces.com/contest/1154/problems&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://codeforces.com/contest/1154&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codeforces.com/contest/1154&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Codeforces" scheme="http://FZ-c.github.io/categories/Codeforces/"/>
    
    
      <category term="Codeforces" scheme="http://FZ-c.github.io/tags/Codeforces/"/>
    
      <category term="div3" scheme="http://FZ-c.github.io/tags/div3/"/>
    
  </entry>
  
  <entry>
    <title>测试赛I题目及题解</title>
    <link href="http://FZ-c.github.io/2019/04/14/%E6%B5%8B%E8%AF%95%E8%B5%9BI%E9%A2%98%E7%9B%AE%E5%8F%8A%E9%A2%98%E8%A7%A3/"/>
    <id>http://FZ-c.github.io/2019/04/14/测试赛I题目及题解/</id>
    <published>2019-04-14T10:03:01.850Z</published>
    <updated>2020-07-08T01:11:44.989Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="http://fzcoj.hustoj.com/contest.php?cid=1061" target="_blank" rel="noopener">http://fzcoj.hustoj.com/contest.php?cid=1061</a></p><a id="more"></a><h2 id="A-amp-B-买游戏"><a href="#A-amp-B-买游戏" class="headerlink" title="A&amp;B.买游戏"></a>A&amp;B.买游戏</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>大家都知道Steam这款理财软件吧？它是当前最大的游戏发布平台之一。玩家可以在该平台购买、下载、讨论、上传和分享游戏和软件。</p><p>老陈最近安利了 $N$ 个朋友来使用Steam，他们有一部分人在Steam上购买了或者退购了某款游戏。</p><p>现在老陈知道他们在这段时间内购买/退购的情况 ，他想请你告诉他他的某些朋友拥有了几个游戏。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>输入三个正整数 $N$ , $M$ , $Q$ ，分别代表被老陈安利来使用Steam的人数，这些人在Steam上的购买/退购记录条数，老陈想知道的朋友的游戏个数的人数。( $1\leq N\leq 10^5$ , $1\leq M \leq 10^6$ , $1\leq Q \leq 10^5$ )</p><p>接下来输入 $M$ 行，每行代表一个购买记录。格式为：</p><blockquote><p>记录类型 购买/退购人 游戏名</p></blockquote><p>记录类型仅包含一个字母：“G”为购买游戏，“T”为退购游戏。购买/退购人和游戏名均为一个长度不大于20且不包含空格的字符串。保证退购的游戏在之前肯定购买且游戏不会重复购买，记录按时间顺序给出。</p><p>接下来$Q$行，每行代表一个询问。</p><p>每行包含一个长度不超过20的字符串，代表老陈询问当前游戏个数的朋友名字。</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>对于每个询问，输出一个整数，代表这位朋友在Steam上拥有的游戏个数。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>3 6 3</p><p>G LiMing SHENZHEN_I/O</p><p>G ZhangSan SUDOKU</p><p>G LiSi CROSS_FIRE</p><p>G LiMing CROSS_FIRE</p><p>T LiSi CROSS_FIRE</p><p>G LiMing SUDOKU</p><p>LiSi</p><p>ZhangSan</p><p>LiMing</p></blockquote><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>0</p><p>1</p><p>3</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于A题：<br>可以使用map来实现存储，对于每个操作，用户游戏数仅会+1或-1。（保证退购的游戏在之前肯定购买且游戏不会重复购买）。</p><p>对于B题：<br>hash一下字符串就行了。<del>（其实A的想法放到B题可以卡过去）</del></p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;inf;</span><br><span class="line">    <span class="keyword">int</span> n, m, q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%*c%d%*c%d%*c"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> type[<span class="number">50</span>], name[<span class="number">50</span>], game[<span class="number">50</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%*c%s%*c%s%*c"</span>, type, name, game);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(type,<span class="string">"G"</span>)==<span class="number">0</span>)</span><br><span class="line">            inf[(<span class="built_in">string</span>)name]++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            inf[(<span class="built_in">string</span>)name]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%*c"</span>, name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, inf[(<span class="built_in">string</span>)name]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-“a”-N"><a href="#C-“a”-N" class="headerlink" title="C.“a”+N"></a>C.“a”+N</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>在C语言中，“a”加上一个数的结果是一个整数。</p><p>例如：“a”+6=97+6=103</p><p>但是老陈觉得这样很无聊，所以他改变了这个加的定义：加N的结果是当前字符串按字典序的顺序之后第N个字符串。</p><p>例如：”az”+4的结果就是”az”之后第四个字符串。(“az”，”ba”，”bb”，”bc”，”bd”)，所以”az”+4=”bd”。</p><p>现在请你编写程序实现它。</p><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h3><p>第一行包含一个正整数$T$，代表数据组数。($1\leq T \leq 1000$)</p><p>接下来$T$行，每行一个测试数据。每个测试数据包含一个字符串$s$和一个正整数$X$。(字符串长度不大于$10^4$且保证非空，$1\leq X \leq 10^{13}$)</p><h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h3><p>对于每组测试数据，输出$s+X$的结果。</p><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>3</p><p>a 10</p><p>abcd 5</p><p>zzz 3</p></blockquote><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>k</p><p>abci</p><p>aaac</p></blockquote><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>将字符串看成26进制数，将数字$X$转化为26进制数后相加即可。相加之后注意进位，按字母输出即可。</p><h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1E4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll arr[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %lld"</span>, s, &amp;n);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            arr[i] = s[len<span class="number">-1</span>-i] - <span class="string">'a'</span>;</span><br><span class="line">        ll next = <span class="number">0</span>;</span><br><span class="line">        arr[<span class="number">0</span>] += n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            next = arr[i] / <span class="number">26</span>;</span><br><span class="line">            arr[i] %= <span class="number">26</span>;</span><br><span class="line">            <span class="keyword">if</span>(next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == len<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    arr[i+<span class="number">1</span>] = next<span class="number">-1</span>;</span><br><span class="line">                    len++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    arr[i+<span class="number">1</span>] += next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, <span class="string">'a'</span> + arr[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-OC数I"><a href="#D-OC数I" class="headerlink" title="D.OC数I"></a>D.OC数I</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>老陈非常喜欢素数，他现在想从某个区间的数中挑出任意个数相乘得到一个新数。如果这个新数是素数，老陈的兴奋值会+1。</p><p>一开始老陈的兴奋值为0，之后他会选择N个区间，对于每个区间他会进行K次操作，当然这K次操作不会存在重复，这样老陈才会真的开心。</p><p>请问最后老陈的兴奋值的最大值是多少？</p><h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h3><p>第一行输入两个数$N$和$K$。($1 \leq N \leq 10^6$,$1\leq K \leq 10^9$)</p><p>接下来$N$行，每行输入两个整数l和r代表老陈进行操作的区间 $[l,r]$。($1\leq l \leq r \leq 10^6$)</p><h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h3><p>输出一个整数代表老陈操作结束后兴奋值的最大值。</p><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>2 5</p><p>2 10</p><p>1000 5000</p></blockquote><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>0</p></blockquote><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>回想一下素数的定义：因子只有1和它自己的数。那么对于一个素数$p$，肯定只有一种乘法表示：$p=1*p$ 。而对于其他的数，相乘的结果肯定不是素数。</p><p>那么，对于没有包含1的区间，对答案的贡献肯定是0。而对于包含1的区间，对答案的贡献为区间内的素数个数。</p><p>素数筛+前缀和即可解决问题。</p><h3 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prime_num[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">bool</span> isprime[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">1000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        prime_num[i] = prime_num[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!isprime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime_num[i]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; i*j &lt;= <span class="number">1000000</span>; j++)</span><br><span class="line">                isprime[i*j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    init();</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ans += (min(prime_num[r], k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-有升有降"><a href="#E-有升有降" class="headerlink" title="E.有升有降"></a>E.有升有降</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>老陈某天的心情值跟过山车一样跌宕起伏，平常的时候，老陈的心情值是不下降的（即可能升高或不变但不会下降）。但是当老陈受到打击的时候<del>（做题自闭什么的）</del>，心情值就是不上升的（即可能下降或不变但不会上升）。</p><p>他的朋友想去安慰<del>（调侃）</del>一下老陈：“你在$a$时间到$b$时间是不是受到了什么打击了啊说给我乐乐？”</p><p>如果老陈在这段时间内的心情值前一部分是不下降的，剩下的部分是不上升的，那么他的朋友才会觉得这个提问有价值。所以请你判断一下这些提问时间是不是有价值的。</p><h3 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h3><p>第一行包含两个整数$n$，$m$。分别代表这一天的时间和他的朋友询问的次数。($1 \leq n,m \leq 10^5$)</p><p>第二行包含$n$个整数代表这一天的每一个时间老陈的心情值。(均不大于$10^9$且均为正整数)</p><p>接下来$m$行，每行包含两个正整数$a$，$b$，代表他的朋友询问的时间段。($1 \leq a \leq b \leq n $)</p><h3 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h3><p>对于每一个时间段，如果是值得提问的，输出”Yes”；否则输出”No”。</p><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>8 6</p><p>1 2 1 3 3 5 2 1</p><p>1 3</p><p>2 3</p><p>2 4</p><p>8 8</p><p>1 4</p><p>5 8</p></blockquote><h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>Yes</p><p>Yes</p><p>No</p><p>Yes</p><p>No</p><p>Yes</p></blockquote><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>$dp[i]$表示以$a[i]$为终点的连续不下降序列的长度，$rdp[i]$表示以$a[i]$为起点的连续不下降序列的长度。</p><p>如果$rdp[l]+dp[r]&gt;=r-l+1$，那么就是$Yes$，否则为$No$。</p><h3 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>], dp[<span class="number">100010</span>], rdp[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, Q, l, r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;Q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= a[i - <span class="number">1</span>])</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= a[i + <span class="number">1</span>])</span><br><span class="line">            rdp[i] = rdp[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rdp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span> (rdp[l] + dp[r] &gt;= r - l + <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-刷墙"><a href="#F-刷墙" class="headerlink" title="F.刷墙"></a>F.刷墙</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>最近老陈的亲戚家重新装修，老陈被叫去帮忙刷墙。</p><p>老陈拿着墙刷，刷着刷着感到无聊就转了一下。这转了一下不要紧，老陈的脑袋突然嗡的一声蹦出一个问题：</p><p>我拿着这个墙刷转一个角度，它涂了多大的面积的墙？</p><p>这问题一出来就不得了，老陈想了好久还没想出来。你能帮他解决吗？</p><p>我们用标准一点的语言来描述这个问题：</p><p>有一个矩形（即墙刷），左边的边长为$a$,上边的边长为$b$，后该矩形以左下角的点为旋转点进行旋转角度 $\theta$（如图所示）。求蓝色区域的面积。</p><p><img src="/2019/04/14/测试赛I题目及题解/TIM图片20190404164108.png" alt="TIM图片20190404164108"></p><h3 id="输入描述-4"><a href="#输入描述-4" class="headerlink" title="输入描述"></a>输入描述</h3><p>输入包含三个整数$a$，$b$，$\theta$。($1\leq a,b\leq 10^6$，$0\leq \theta \leq 180$)</p><h3 id="输出描述-4"><a href="#输出描述-4" class="headerlink" title="输出描述"></a>输出描述</h3><p>输出一个数代表所求面积，保留三位小数。</p><h3 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h3><blockquote><p>2 2 90</p></blockquote><h3 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h3><blockquote><p>10.283</p></blockquote><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p><img src="/2019/04/14/测试赛I题目及题解/图片1.png" alt="图片1"></p><p>答案即为扇形面积加上区域$I$和区域$II$的面积。（即矩形面积）</p><h3 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, k, q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; k &gt;&gt; q;</span><br><span class="line">    ll r = c * c + k * k;</span><br><span class="line">    ll ju = c * k;</span><br><span class="line">    <span class="keyword">double</span> ans = q / <span class="number">360.0</span> * PI * r + ju;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3lf"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><strong>E题若角度范围增大为360的话该怎么处理呢？</strong></p><h2 id="补题？"><a href="#补题？" class="headerlink" title="补题？"></a>补题？</h2><p>传送门：<a href="http://fzcoj.hustoj.com/contest.php?cid=1061" target="_blank" rel="noopener">http://fzcoj.hustoj.com/contest.php?cid=1061</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://fzcoj.hustoj.com/contest.php?cid=1061&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://fzcoj.hustoj.com/contest.php?cid=1061&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="FZCOJ" scheme="http://FZ-c.github.io/categories/FZCOJ/"/>
    
    
      <category term="FZCOJ" scheme="http://FZ-c.github.io/tags/FZCOJ/"/>
    
      <category term="集训队" scheme="http://FZ-c.github.io/tags/%E9%9B%86%E8%AE%AD%E9%98%9F/"/>
    
      <category term="测试赛" scheme="http://FZ-c.github.io/tags/%E6%B5%8B%E8%AF%95%E8%B5%9B/"/>
    
  </entry>
  
</feed>
